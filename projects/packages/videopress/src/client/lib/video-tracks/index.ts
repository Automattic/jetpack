/**
 * External dependencies
 */
import apiFetch from '@wordpress/api-fetch';
import debugFactory from 'debug';
/**
 * Internal dependencies
 */
import getMediaToken from '../get-media-token';
import { DeleteTrackDataProps, UploadTrackDataProps } from './types';
/**
 * Types
 */
import type { VideoGUID } from '../../block-editor/blocks/video/types';
import type { MediaTokenProps } from '../get-media-token/types';

export const TRACK_KIND_OPTIONS = [
	'subtitles',
	'captions',
	'descriptions',
	'chapters',
	'metadata',
] as const;

const { siteType = '' } = window?.videoPressEditorState || {};
const shouldUseJetpackVideoFetch = siteType !== 'simple';
const debug = debugFactory( 'videopress:tracks:lib:video-tracks' );

type isAutogeneratedChaterFileParamsProps = {
	guid?: VideoGUID;
	isPrivate?: boolean;
};

/**
 * Load the file content, and check if it's autogenerated,
 * based on the `videopress-chapters-auto-generated` comment.
 * The function will try to anticipate the video privacy,
 * based on the block attributes.
 * If the first request fails, it will try again with the token.
 *
 * @param {string} fileUrl                              - the track file url
 * @param {isAutogeneratedChaterFileParamsProps} params - function parameters
 * @returns {Promise<boolean>}   true if the file is autogenerated.
 */
export async function isAutogeneratedChapterFile(
	fileUrl: string,
	params?: isAutogeneratedChaterFileParamsProps
): Promise< boolean > {
	if ( ! fileUrl ) {
		return false;
	}

	let tokenData: null | MediaTokenProps;
	let queryString = '';

	// Try to anticipate the video privacy, based on the block attributes.
	if ( params.isPrivate ) {
		tokenData = await getMediaToken( 'playback', { guid: params.guid } );
		queryString = '?' + new URLSearchParams( { metadata_token: tokenData?.token } ).toString();
	}

	let response = await fetch( fileUrl + queryString );

	// If the file is private, and response is 403, try with the token.
	if ( ! response.ok && response.status === 403 && params.guid ) {
		tokenData = await getMediaToken( 'playback', { guid: params.guid } );
		queryString = '?' + new URLSearchParams( { metadata_token: tokenData?.token } ).toString();
		response = await fetch( fileUrl + queryString );
	}

	if ( ! response.ok ) {
		return false;
	}

	const text = await response.text();
	return /videopress-chapters-auto-generated/.test( text );
}

const videoPressUploadTrack = function ( track: UploadTrackDataProps, guid: string ) {
	debug( 'using jetpack api fetch' );
	return new Promise( function ( resolve, reject ) {
		const { kind, srcLang, label, tmpFile: vttFile } = track;

		getMediaToken( 'upload', { filename: vttFile.name } ).then( ( { token, blogId } ) => {
			const body = new FormData();
			body.append( 'kind', kind );
			body.append( 'srclang', srcLang );
			body.append( 'label', label );
			body.append( 'vtt', vttFile );

			const requestOptions = {
				headers: {
					// Set auth header with upload token.
					Authorization: `X_UPLOAD_TOKEN token="${ token }" blog_id="${ blogId }"`,
				},
				method: 'POST',
				body,
			};

			fetch( `https://public-api.wordpress.com/rest/v1.1/videos/${ guid }/tracks`, requestOptions )
				.then( data => {
					try {
						const json = data.json();
						debug( 'data', data );
						debug( 'json', json );
						return resolve( json );
					} catch ( error ) {
						debug( 'error', error );
						return reject( error );
					}
				} )
				.catch( reject );
		} );
	} );
};

/**
 * Uploads a track to a video.
 * Uses different methods depending on Jetpack or WPCOM.
 *
 * @param {object} track - the track file
 * @param {string} guid - the video guid
 * @returns {Promise} the api request promise
 */
export const uploadTrackForGuid = ( track: UploadTrackDataProps, guid: string ) => {
	const { kind, srcLang, label, tmpFile } = track;

	if ( shouldUseJetpackVideoFetch ) {
		return videoPressUploadTrack( { kind, srcLang, label, tmpFile }, guid );
	}
	debug( 'using wpcom api fetch' );
	return new Promise( function ( resolve, reject ) {
		return apiFetch( {
			method: 'POST',
			path: `/videos/${ guid }/tracks`,
			apiNamespace: 'rest/v1.1',
			global: true,
			parse: false,
			formData: [
				[ 'kind', kind ],
				[ 'srclang', srcLang ],
				[ 'label', label ],
				[ 'vtt', tmpFile ],
			],
		} )
			.then( data => {
				try {
					const json = data.json();
					debug( 'data', data );
					debug( 'json', json );
					return resolve( json );
				} catch ( error ) {
					debug( 'error', error );
					return reject( error );
				}
			} )
			.catch( reject );
	} );
};

const videoPressDeleteTrack = function ( { kind, srcLang }, guid ) {
	// eslint-disable-next-line no-undef
	return new Promise( function ( resolve, reject ) {
		getMediaToken( 'upload' ).then( ( { token, blogId } ) => {
			const body = new FormData();
			body.append( 'kind', kind );
			body.append( 'srclang', srcLang );

			const requestOptions = {
				headers: {
					// Set auth header with upload token.
					Authorization: `X_UPLOAD_TOKEN token="${ token }" blog_id="${ blogId }"`,
				},
				method: 'POST',
				body,
			};

			fetch(
				`https://public-api.wordpress.com/rest/v1.1/videos/${ guid }/tracks/delete`,
				requestOptions
			)
				.then( data => {
					try {
						return resolve( data.json() );
					} catch ( error ) {
						return reject( error );
					}
				} )
				.catch( reject );
		} );
	} );
};

/**
 * -Deletes a track from a video.
 * -Uses different methods depending on Jetpack or WPCOM.
 *
 * @param {object} track - the track file
 * @param {string} guid - the video guid
 * @returns {Promise} the api request promise
 */
export const deleteTrackForGuid = ( track: DeleteTrackDataProps, guid: string ) => {
	const { kind, srcLang } = track;

	if ( shouldUseJetpackVideoFetch ) {
		return videoPressDeleteTrack( { kind, srcLang }, guid );
	}

	const options = {
		method: 'POST',
		path: `/videos/${ guid }/tracks/delete`,
		apiNamespace: 'rest/v1.1',
		global: true,
		parse: false,
		formData: [
			[ 'kind', kind ],
			[ 'srclang', srcLang ],
		],
	};

	return apiFetch( options );
};
