# Async Options

Async Options is a library that provides APIs in both in WordPress and Svelte to make passing data seamless between the WordPress backend and the Svelte frontend.

## Quick Tour

Async Options differ from regular options in that they must be explicitly registered using the Async Option Registry.

Having a streamlined way to register these options allows us to:

- Be clear about what options are available
- Ensure that any necessary transformation/validation/sanitization actions are performed at predictable times
- Provide a structured way to pass the option data to the frontend on page load
- Automatically generate REST API CRUD endpoints that can be used by the Svelte front-end
- Automatically set-up a nonce for every option that is registered
- Have typed Svelte options stores that automatically sync with WordPress Options

### Quick Setup

As an example, I'm going to set-up a new option called `widget_status` that will be used to determine if a widget is enabled or not.

#### Step 1: Register the Option in PHP

The snippet below is going to:

- Ensure that the value is sanitized both when saving and when retrieving the option from the database.
- Create an endpoint `/wp-json/widget-plugin/widget-status` that's going to accept al REST API requests.
- Setup and take care of nonce validation

```php
	class Widget_Status extends Async_Option_Template {

		// A sanitize method is called before the option is saved to the database.
		public function sanitize( $value ): bool {
			return filter_var( $value, FILTER_VALIDATE_BOOLEAN );
		}

		// Transform the value when retrieving the option from the database.
		public function transform( $value ) {
			return filter_var( $value, FILTER_VALIDATE_BOOLEAN );
		}

	}

	// Registry is a Singleton based on the key provided. A new instance is going to be created if one doesn't exist.
	Registry::get_instance( 'widget_plugin' )
			->register( 'widget_status', new Widgets_Status() );
```

#### Step 2: Pass data on page load

Script names and locations can vary depending on the plugin, so a little bit of setup is necessary to tell Async Options which script to attach to.

To do this, use `Async_Options::setup()` method:

```php
// This only needs to happen in the Admin Dashboard:
add_action( 'admin_init', function() {
	// Notice that widget_plugin matches the registry key.
	// `widget-plugin-scripts` in this example is the script file name
	// that's enqueued by WordPress in the plugin page.
	Async_Options::setup( 'widget_plugin', 'widget-plugin-scripts' );
} );
```

#### Step 3: Register the option in Svelte

The option is passed to the front-end via `window.widget_plugin` global variables.

[Zod](https://zod.dev) is used to ensure that the values are properly typed and match the expectations:

```ts
const Widget_Options = z.object({
	// This is required for all Async_Options instances.
	rest_api: z.object({
		value: z.string().url(),
		nonce: z.string(),
	}),

	// This is the template that all Async Options should follow:
	// Each Async Option that's registered is going to be an object with two keys:
	// - `value`: The value of the option
	// - `nonce`: The nonce for the option
	widget_status: z.object({
		// We're the value of status to be a boolean, Zod allows us to declare that trigger an error if the value doesn't match our expectation.
		value: z.boolean(),

		// Nonce is always a string and is automatically generated by in the Endpoint PHP Class.
		nonce: z.string(),
	}),
});

// window.widget_plugin is the variable, but it's unsafe to read
// This is a helper function that's going to use Widget_Options Zod type to extract the values from the window object and validate them.
const async = createAsyncFactory("widget_plugin", Widget_Options);

// This is going to set-up a Svelte store that's going to automatically sync back with WordPress any time the value of the option changes.
export const widgetStatus = async.createStore("widget_status");
```

And that's it, now `widgetStatus` is a fully typed store that's going to automatically sync with WordPress.

#### Step 4: Use the store in components

Registering an async option using `async.createStore()` will create a store with two reactive values:

- value: The value of the option. This will dispatch POST requests to the REST API endpoint when the value changes.
- pending: Whether the value is being currently being sent to the server

Here's a simple version of how that would work:

```svelte
<script type="ts">
	import { widgetStatus } from "./widget-options.ts";
	status = widgetStatus.value;
	pending = widgetStatus.pending;
</script>

{#if $pending}
	 ðŸŒŠ I'm updating the value
{/if}

<input type="checkbox" bind:checked={$status} /> Enable Widget
```

There's now a fully type safe stores that automatically sync front-end and back-end, and will deal deal with sanitization, validation, transformation, nonces, REST API.

To summarize:

1. Create an Async Option Template based class in PHP
2. Register the option in using the Registry class
3. Tell TypeScript what the shape of the global variable looks like
4. Register the zod-validated store in Svelte
5. Create async stores and use them like normal svelte stores

## Utility Functions

You might have noticed that the registration process is a bit clunky. To aid with that. create plugin specific functions that simplify interaction with the Async Options registry:

```php
function widgetplug_get_option( $name ) {
	return Registry::get_instance( 'widget_plugin' )->get_option( $name );
}

function widgetplug_register_option( $name, $handler ) {
	return Registry::get_instance( 'widget_plugin' )
	               ->regsiter( $name, $handler );
}
```

Now registering new options becomes easy to parse at a glance:

```php
widgetplug_register_option( 'widget_status', new Widget_Status() );
widgetplug_register_option( 'widget_title', new Widget_Text_Field() );
widgetplug_register_option( 'widget_text', new Widget_Text_Field() );
```
