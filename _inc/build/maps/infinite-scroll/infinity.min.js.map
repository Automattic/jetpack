{"version":3,"sources":["infinite-scroll/infinity.js"],"names":["$","fullscreenState","document","fullscreenElement","mozFullScreenElement","webkitFullscreenElement","msFullscreenElement","Scroller","ajaxurl","stats","type","text","totop","isIE","navigator","userAgent","search","IEVersion","match","parseInt","location","protocol","infiniteScroll","settings","replace","self","this","id","body","window","element","wrapperClass","wrapper_class","ready","disabled","page","offset","currentday","order","throttle","handle","click_handle","google_analytics","history","origURL","href","pageCache","footer","wrap","wpMediaelement","bind","gotop","setInterval","thefooter","refresh","determineURL","ensureFilledViewport","checkViewportOnLoad","append","delegate","remove","initializeMejs","prototype","check","container","scrollTop","height","top","outerHeight","render","response","addClass","html","trigger","query","scripts","styles","query_args","query_before","last_post_date","blog","attr","e","animate","preventDefault","width","outerWidth","find","css","bottom","jqxhr","load","loader","color","customized","spin","error","extend","action","wp","customize","theme","wp_customize","stylesheet","each","setting","_dirty","JSON","stringify","nonce","preview","post","fail","hide","done","elementToAppendTo","push","extra_data","data","createElement","dataContent","createTextNode","appendChild","getElementsByTagName","script","src","unbind","mejs","tag","setTimeout","maybeLoadMejs","style","rel","conditional","eval","Image","Math","random","postflair","WPCOM_sharing_counts","apply","arguments","lastbatch","removeClass","ga_url","path","_gaq","ga","ev","indexOf","_wpmejsSettings","pluginPath","success","autoplay","attributes","pluginType","addEventListener","play","not","mediaelementplayer","windowHeight","postsHeight","aveSetHeight","wrapperQty","selector","previousFullScrenState","windowTop","windowBottom","windowSize","setsInView","setsHidden","pageNum","currentFullScreenState","setTop","setHeight","setBottom","setPageNum","$set","hasClass","empty","length","setData","pop","majorityPercentageInView","i","topInView","bottomInView","percentOfView","updateURL","pushState","pageSlug","host","parameters","pause","resume","body_class","scroller","timer","selectiveRefresh","placement","content","addedContent","MutationObserver","on","rootElement","addPartials","jQuery"],"mappings":"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","file":"../../infinite-scroll/infinity.min.js","sourcesContent":["/* Do not modify this file directly. It is compiled from other files. */\n(function($){ // Open closure\n// Local vars\nvar Scroller, ajaxurl, stats, type, text, totop;\n\n// IE requires special handling\nvar isIE = ( -1 != navigator.userAgent.search( 'MSIE' ) );\nif ( isIE ) {\n\tvar IEVersion = navigator.userAgent.match(/MSIE\\s?(\\d+)\\.?\\d*;/);\n\tvar IEVersion = parseInt( IEVersion[1] );\n}\n\n// HTTP ajaxurl when site is HTTPS causes Access-Control-Allow-Origin failure in Desktop and iOS Safari\nif ( \"https:\" == document.location.protocol ) {\n\tinfiniteScroll.settings.ajaxurl = infiniteScroll.settings.ajaxurl.replace( \"http://\", \"https://\" );\n}\n\n/**\n * Loads new posts when users scroll near the bottom of the page.\n */\nScroller = function( settings ) {\n\tvar self = this;\n\n\t// Initialize our variables\n\tthis.id               = settings.id;\n\tthis.body             = $( document.body );\n\tthis.window           = $( window );\n\tthis.element          = $( '#' + settings.id );\n\tthis.wrapperClass     = settings.wrapper_class;\n\tthis.ready            = true;\n\tthis.disabled         = false;\n\tthis.page             = 1;\n\tthis.offset           = settings.offset;\n\tthis.currentday       = settings.currentday;\n\tthis.order            = settings.order;\n\tthis.throttle         = false;\n\tthis.handle           = '<div id=\"infinite-handle\"><span><button>' + text.replace( '\\\\', '' ) + '</button></span></div>';\n\tthis.click_handle     = settings.click_handle;\n\tthis.google_analytics = settings.google_analytics;\n\tthis.history          = settings.history;\n\tthis.origURL          = window.location.href;\n\tthis.pageCache        = {};\n\n\t// Footer settings\n\tthis.footer           = $( '#infinite-footer' );\n\tthis.footer.wrap      = settings.footer;\n\n\t// Core's native MediaElement.js implementation needs special handling\n\tthis.wpMediaelement   = null;\n\n\t// We have two type of infinite scroll\n\t// cases 'scroll' and 'click'\n\n\tif ( type == 'scroll' ) {\n\t\t// Bind refresh to the scroll event\n\t\t// Throttle to check for such case every 300ms\n\n\t\t// On event the case becomes a fact\n\t\tthis.window.bind( 'scroll.infinity', function() {\n\t\t\tthis.throttle = true;\n\t\t});\n\n\t\t// Go back top method\n\t\tself.gotop();\n\n\t\tsetInterval( function() {\n\t\t\tif ( this.throttle ) {\n\t\t\t\t// Once the case is the case, the action occurs and the fact is no more\n\t\t\t\tthis.throttle = false;\n\t\t\t\t// Reveal or hide footer\n\t\t\t\tself.thefooter();\n\t\t\t\t// Fire the refresh\n\t\t\t\tself.refresh();\n                self.determineURL(); // determine the url\n\t\t\t}\n\t\t}, 250 );\n\n\t\t// Ensure that enough posts are loaded to fill the initial viewport, to compensate for short posts and large displays.\n\t\tself.ensureFilledViewport();\n\t\tthis.body.bind( 'post-load', { self: self }, self.checkViewportOnLoad );\n\t} else if ( type == 'click' ) {\n\t\tif ( this.click_handle ) {\n\t\t\tthis.element.append( this.handle );\n\t\t}\n\n\t\tthis.body.delegate( '#infinite-handle', 'click.infinity', function() {\n\t\t\t// Handle the handle\n\t\t\tif ( self.click_handle ) {\n\t\t\t\t$( '#infinite-handle' ).remove();\n\t\t\t}\n\n\t\t\t// Fire the refresh\n\t\t\tself.refresh();\n\t\t});\n\t}\n\n\t// Initialize any Core audio or video players loaded via IS\n\tthis.body.bind( 'post-load', { self: self }, self.initializeMejs );\n};\n\n/**\n * Check whether we should fetch any additional posts.\n */\nScroller.prototype.check = function() {\n\tvar container = this.element.offset();\n\n\t// If the container can't be found, stop otherwise errors result\n\tif ( 'object' !== typeof container ) {\n\t\treturn false;\n\t}\n\n\tvar bottom = this.window.scrollTop() + this.window.height(),\n\t\tthreshold = container.top + this.element.outerHeight(false) - (this.window.height() * 2);\n\n\treturn bottom > threshold;\n};\n\n/**\n * Renders the results from a successful response.\n */\nScroller.prototype.render = function( response ) {\n\tthis.body.addClass( 'infinity-success' );\n\n\t// Check if we can wrap the html\n\tthis.element.append( response.html );\n\tthis.body.trigger( 'post-load', response );\n\tthis.ready = true;\n};\n\n/**\n * Returns the object used to query for new posts.\n */\nScroller.prototype.query = function() {\n\treturn {\n\t\tpage          : this.page + this.offset, // Load the next page.\n\t\tcurrentday    : this.currentday,\n\t\torder         : this.order,\n\t\tscripts       : window.infiniteScroll.settings.scripts,\n\t\tstyles        : window.infiniteScroll.settings.styles,\n\t\tquery_args    : window.infiniteScroll.settings.query_args,\n\t\tquery_before  : window.infiniteScroll.settings.query_before,\n\t\tlast_post_date: window.infiniteScroll.settings.last_post_date\n\t};\n};\n\n/**\n * Scroll back to top.\n */\nScroller.prototype.gotop = function() {\n\tvar blog = $( '#infinity-blog-title' );\n\n\tblog.attr( 'title', totop );\n\n\t// Scroll to top on blog title\n\tblog.bind( 'click', function( e ) {\n\t\t$( 'html, body' ).animate( { scrollTop: 0 }, 'fast' );\n\t\te.preventDefault();\n\t});\n};\n\n\n/**\n * The infinite footer.\n */\nScroller.prototype.thefooter = function() {\n\tvar self  = this,\n\t\twidth;\n\n\t// Check if we have an id for the page wrapper\n\tif ( $.type( this.footer.wrap ) === \"string\" ) {\n\t\twidth = $( 'body #' + this.footer.wrap ).outerWidth( false );\n\n\t\t// Make the footer match the width of the page\n\t\tif ( width > 479 )\n\t\t\tthis.footer.find( '.container' ).css( 'width', width );\n\t}\n\n\t// Reveal footer\n\tif ( this.window.scrollTop() >= 350 )\n\t\tself.footer.animate( { 'bottom': 0 }, 'fast' );\n\telse if ( this.window.scrollTop() < 350 )\n\t\tself.footer.animate( { 'bottom': '-50px' }, 'fast' );\n};\n\n\n/**\n * Controls the flow of the refresh. Don't mess.\n */\nScroller.prototype.refresh = function() {\n\tvar\tself   = this,\n\t\tquery, jqxhr, load, loader, color, customized;\n\n\t// If we're disabled, ready, or don't pass the check, bail.\n\tif ( this.disabled || ! this.ready || ! this.check() )\n\t\treturn;\n\n\t// Let's get going -- set ready to false to prevent\n\t// multiple refreshes from occurring at once.\n\tthis.ready = false;\n\n\t// Create a loader element to show it's working.\n\tif ( this.click_handle ) {\n\t\tloader = '<span class=\"infinite-loader\"></span>';\n\t\tthis.element.append( loader );\n\n\t\tloader = this.element.find( '.infinite-loader' );\n\t\tcolor = loader.css( 'color' );\n\n\t\ttry {\n\t\t\tloader.spin( 'medium-left', color );\n\t\t} catch ( error ) { }\n\t}\n\n\t// Generate our query vars.\n\tquery = $.extend({\n\t\taction: 'infinite_scroll'\n\t}, this.query() );\n\n\t// Inject Customizer state.\n\tif ( 'undefined' !== typeof wp && wp.customize && wp.customize.settings.theme ) {\n\t\tcustomized = {};\n\t\tquery.wp_customize = 'on';\n\t\tquery.theme = wp.customize.settings.theme.stylesheet;\n\t\twp.customize.each( function( setting ) {\n\t\t\tif ( setting._dirty ) {\n\t\t\t\tcustomized[ setting.id ] = setting();\n\t\t\t}\n\t\t} );\n\t\tquery.customized = JSON.stringify( customized );\n\t\tquery.nonce = wp.customize.settings.nonce.preview;\n\t}\n\n\t// Fire the ajax request.\n\tjqxhr = $.post( infiniteScroll.settings.ajaxurl, query );\n\n\t// Allow refreshes to occur again if an error is triggered.\n\tjqxhr.fail( function() {\n\t\tif ( self.click_handle ) {\n\t\t\tloader.hide();\n\t\t}\n\n\t\tself.ready = true;\n\t});\n\n\t// Success handler\n\tjqxhr.done( function( response ) {\n\t\t\t// On success, let's hide the loader circle.\n\t\t\tif ( self.click_handle ) {\n\t\t\t\tloader.hide();\n\t\t\t}\n\n\t\t\t// Check for and parse our response.\n\t\t\tif ( ! response || ! response.type ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If we've succeeded...\n\t\t\tif ( response.type == 'success' ) {\n\t\t\t\t// If additional scripts are required by the incoming set of posts, parse them\n\t\t\t\tif ( response.scripts ) {\n\t\t\t\t\t$( response.scripts ).each( function() {\n\t\t\t\t\t\tvar elementToAppendTo = this.footer ? 'body' : 'head';\n\n\t\t\t\t\t\t// Add script handle to list of those already parsed\n\t\t\t\t\t\twindow.infiniteScroll.settings.scripts.push( this.handle );\n\n\t\t\t\t\t\t// Output extra data, if present\n\t\t\t\t\t\tif ( this.extra_data ) {\n\t\t\t\t\t\t\tvar data = document.createElement('script'),\n\t\t\t\t\t\t\t\tdataContent = document.createTextNode( \"//<![CDATA[ \\n\" + this.extra_data + \"\\n//]]>\" );\n\n\t\t\t\t\t\t\tdata.type = 'text/javascript';\n\t\t\t\t\t\t\tdata.appendChild( dataContent );\n\n\t\t\t\t\t\t\tdocument.getElementsByTagName( elementToAppendTo )[0].appendChild(data);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Build script tag and append to DOM in requested location\n\t\t\t\t\t\tvar script = document.createElement('script');\n\t\t\t\t\t\tscript.type = 'text/javascript';\n\t\t\t\t\t\tscript.src = this.src;\n\t\t\t\t\t\tscript.id = this.handle;\n\n\t\t\t\t\t\t// If MediaElement.js is loaded in by this set of posts, don't initialize the players a second time as it breaks them all\n\t\t\t\t\t\tif ( 'wp-mediaelement' === this.handle ) {\n\t\t\t\t\t\t\tself.body.unbind( 'post-load', self.initializeMejs );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( 'wp-mediaelement' === this.handle && 'undefined' === typeof mejs ) {\n\t\t\t\t\t\t\tself.wpMediaelement = {};\n\t\t\t\t\t\t\tself.wpMediaelement.tag = script;\n\t\t\t\t\t\t\tself.wpMediaelement.element = elementToAppendTo;\n\t\t\t\t\t\t\tsetTimeout( self.maybeLoadMejs.bind( self ), 250 );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocument.getElementsByTagName( elementToAppendTo )[0].appendChild(script);\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\t// If additional stylesheets are required by the incoming set of posts, parse them\n\t\t\t\tif ( response.styles ) {\n\t\t\t\t\t$( response.styles ).each( function() {\n\t\t\t\t\t\t// Add stylesheet handle to list of those already parsed\n\t\t\t\t\t\twindow.infiniteScroll.settings.styles.push( this.handle );\n\n\t\t\t\t\t\t// Build link tag\n\t\t\t\t\t\tvar style = document.createElement('link');\n\t\t\t\t\t\tstyle.rel = 'stylesheet';\n\t\t\t\t\t\tstyle.href = this.src;\n\t\t\t\t\t\tstyle.id = this.handle + '-css';\n\n\t\t\t\t\t\t// Destroy link tag if a conditional statement is present and either the browser isn't IE, or the conditional doesn't evaluate true\n\t\t\t\t\t\tif ( this.conditional && ( ! isIE || ! eval( this.conditional.replace( /%ver/g, IEVersion ) ) ) )\n\t\t\t\t\t\t\tvar style = false;\n\n\t\t\t\t\t\t// Append link tag if necessary\n\t\t\t\t\t\tif ( style )\n\t\t\t\t\t\t\tdocument.getElementsByTagName('head')[0].appendChild(style);\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\t// stash the response in the page cache\n\t\t\t\tself.pageCache[self.page+self.offset] = response;\n\n\t\t\t\t// Increment the page number\n\t\t\t\tself.page++;\n\n\t\t\t\t// Record pageview in WP Stats, if available.\n\t\t\t\tif ( stats )\n\t\t\t\t\tnew Image().src = document.location.protocol + '//pixel.wp.com/g.gif?' + stats + '&post=0&baba=' + Math.random();\n\n\t\t\t\t// Add new posts to the postflair object\n\t\t\t\tif ( 'object' == typeof response.postflair && 'object' == typeof WPCOM_sharing_counts )\n\t\t\t\t\tWPCOM_sharing_counts = $.extend( WPCOM_sharing_counts, response.postflair );\n\n\t\t\t\t// Render the results\n\t\t\t\tself.render.apply( self, arguments );\n\n\t\t\t\t// If 'click' type and there are still posts to fetch, add back the handle\n\t\t\t\tif ( type == 'click' ) {\n\t\t\t\t\tif ( response.lastbatch ) {\n\t\t\t\t\t\tif ( self.click_handle ) {\n\t\t\t\t\t\t\t$( '#infinite-handle' ).remove();\n\t\t\t\t\t\t\t// Update body classes\n\t\t\t\t\t\t\tself.body.addClass( 'infinity-end' ).removeClass( 'infinity-success' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.body.trigger( 'infinite-scroll-posts-end' );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( self.click_handle ) {\n\t\t\t\t\t\t\tself.element.append( self.handle );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.body.trigger( 'infinite-scroll-posts-more' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if ( response.lastbatch ) {\n\t\t\t\t\tself.disabled = true;\n\t\t\t\t\tself.body.addClass( 'infinity-end' ).removeClass( 'infinity-success' );\n\t\t\t\t}\n\n\t\t\t\t// Update currentday to the latest value returned from the server\n\t\t\t\tif ( response.currentday ) {\n\t\t\t\t\tself.currentday = response.currentday;\n\t\t\t\t}\n\n\t\t\t\t// Fire Google Analytics pageview\n\t\t\t\tif ( self.google_analytics ) {\n\t\t\t\t\tvar ga_url = self.history.path.replace( /%d/, self.page );\n\t\t\t\t\tif ( 'object' === typeof _gaq ) {\n\t\t\t\t\t\t_gaq.push( [ '_trackPageview', ga_url ] );\n\t\t\t\t\t}\n\t\t\t\t\tif ( 'function' === typeof ga ) {\n\t\t\t\t\t\tga( 'send', 'pageview', ga_url );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\treturn jqxhr;\n};\n\n/**\n * Core's native media player uses MediaElement.js\n * The library's size is sufficient that it may not be loaded in time for Core's helper to invoke it, so we need to delay until `mejs` exists.\n */\nScroller.prototype.maybeLoadMejs = function() {\n\tif ( null === this.wpMediaelement ) {\n\t\treturn;\n\t}\n\n\tif ( 'undefined' === typeof mejs ) {\n\t\tsetTimeout( this.maybeLoadMejs, 250 );\n\t} else {\n\t\tdocument.getElementsByTagName( this.wpMediaelement.element )[0].appendChild( this.wpMediaelement.tag );\n\t\tthis.wpMediaelement = null;\n\n\t\t// Ensure any subsequent IS loads initialize the players\n\t\tthis.body.bind( 'post-load', { self: this }, this.initializeMejs );\n\t}\n}\n\n/**\n * Initialize the MediaElement.js player for any posts not previously initialized\n */\nScroller.prototype.initializeMejs = function( ev, response ) {\n\t// Are there media players in the incoming set of posts?\n\tif ( ! response.html || -1 === response.html.indexOf( 'wp-audio-shortcode' ) && -1 === response.html.indexOf( 'wp-video-shortcode' ) ) {\n\t\treturn;\n\t}\n\n\t// Don't bother if mejs isn't loaded for some reason\n\tif ( 'undefined' === typeof mejs ) {\n\t\treturn;\n\t}\n\n\t// Adapted from wp-includes/js/mediaelement/wp-mediaelement.js\n\t// Modified to not initialize already-initialized players, as Mejs doesn't handle that well\n\t$(function () {\n\t\tvar settings = {};\n\n\t\tif ( typeof _wpmejsSettings !== 'undefined' ) {\n\t\t\tsettings.pluginPath = _wpmejsSettings.pluginPath;\n\t\t}\n\n\t\tsettings.success = function (mejs) {\n\t\t\tvar autoplay = mejs.attributes.autoplay && 'false' !== mejs.attributes.autoplay;\n\t\t\tif ( 'flash' === mejs.pluginType && autoplay ) {\n\t\t\t\tmejs.addEventListener( 'canplay', function () {\n\t\t\t\t\tmejs.play();\n\t\t\t\t}, false );\n\t\t\t}\n\t\t};\n\n\t\t$('.wp-audio-shortcode, .wp-video-shortcode').not( '.mejs-container' ).mediaelementplayer( settings );\n\t});\n}\n\n/**\n * Trigger IS to load additional posts if the initial posts don't fill the window.\n * On large displays, or when posts are very short, the viewport may not be filled with posts, so we overcome this by loading additional posts when IS initializes.\n */\nScroller.prototype.ensureFilledViewport = function() {\n\tvar\tself = this,\n\t   \twindowHeight = self.window.height(),\n\t   \tpostsHeight = self.element.height(),\n\t   \taveSetHeight = 0,\n\t   \twrapperQty = 0;\n\n\t// Account for situations where postsHeight is 0 because child list elements are floated\n\tif ( postsHeight === 0 ) {\n\t\t$( self.element.selector + ' > li' ).each( function() {\n\t\t\tpostsHeight += $( this ).height();\n\t\t} );\n\n\t\tif ( postsHeight === 0 ) {\n\t\t\tself.body.unbind( 'post-load', self.checkViewportOnLoad );\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Calculate average height of a set of posts to prevent more posts than needed from being loaded.\n\t$( '.' + self.wrapperClass ).each( function() {\n\t\taveSetHeight += $( this ).height();\n\t\twrapperQty++;\n\t} );\n\n\tif ( wrapperQty > 0 )\n\t\taveSetHeight = aveSetHeight / wrapperQty;\n\telse\n\t\taveSetHeight = 0;\n\n\t// Load more posts if space permits, otherwise stop checking for a full viewport\n\tif ( postsHeight < windowHeight && ( postsHeight + aveSetHeight < windowHeight ) ) {\n\t\tself.ready = true;\n\t\tself.refresh();\n\t}\n\telse {\n\t\tself.body.unbind( 'post-load', self.checkViewportOnLoad );\n\t}\n}\n\n/**\n * Event handler for ensureFilledViewport(), tied to the post-load trigger.\n * Necessary to ensure that the variable `this` contains the scroller when used in ensureFilledViewport(). Since this function is tied to an event, `this` becomes the DOM element the event is tied to.\n */\nScroller.prototype.checkViewportOnLoad = function( ev ) {\n\tev.data.self.ensureFilledViewport();\n}\n\nfunction fullscreenState() {\n\treturn document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement\n\t\t? 1\n\t\t: 0;\n}\n\nvar previousFullScrenState = fullscreenState();\n\n/**\n * Identify archive page that corresponds to majority of posts shown in the current browser window.\n */\nScroller.prototype.determineURL = function () {\n\tvar self         = this,\n\t\twindowTop    = $( window ).scrollTop(),\n\t\twindowBottom = windowTop + $( window ).height(),\n\t\twindowSize   = windowBottom - windowTop,\n\t\tsetsInView   = [],\n\t\tsetsHidden   = [],\n\t\tpageNum      = false,\n\t\tcurrentFullScreenState = fullscreenState();\n\n\t// xor - check if the state has changed\n\tif ( previousFullScrenState ^ currentFullScreenState ) {\n\t\t// If we just switched to/from fullscreen,\n\t\t// don't do the div clearing/caching or the\n\t\t// URL setting. Doing so can break video playback\n\t\t// if the video goes to fullscreen.\n\n\t\tpreviousFullScrenState = currentFullScreenState;\n\t\treturn;\n\t}\n\tpreviousFullScrenState = currentFullScreenState;\n\n\t// Find out which sets are in view\n\t$( '.' + self.wrapperClass ).each( function() {\n\t\tvar id         = $( this ).attr( 'id' ),\n\t\t\tsetTop     = $( this ).offset().top,\n\t\t\tsetHeight  = $( this ).outerHeight( false ),\n\t\t\tsetBottom  = 0,\n\t\t\tsetPageNum = $( this ).data( 'page-num' );\n\n\t\t// Account for containers that have no height because their children are floated elements.\n\t\tif ( 0 === setHeight ) {\n\t\t\t$( '> *', this ).each( function() {\n\t\t\t\tsetHeight += $( this ).outerHeight( false );\n\t\t\t} );\n\t\t}\n\n\t\t// Determine position of bottom of set by adding its height to the scroll position of its top.\n\t\tsetBottom = setTop + setHeight;\n\n\t\t// Populate setsInView object. While this logic could all be combined into a single conditional statement, this is easier to understand.\n\t\tif ( setTop < windowTop && setBottom > windowBottom ) { // top of set is above window, bottom is below\n\t\t\tsetsInView.push({'id': id, 'top': setTop, 'bottom': setBottom, 'pageNum': setPageNum });\n\t\t}\n\t\telse if( setTop > windowTop && setTop < windowBottom ) { // top of set is between top (gt) and bottom (lt)\n\t\t\tsetsInView.push({'id': id, 'top': setTop, 'bottom': setBottom, 'pageNum': setPageNum });\n\t\t}\n\t\telse if( setBottom > windowTop && setBottom < windowBottom ) { // bottom of set is between top (gt) and bottom (lt)\n\t\t\tsetsInView.push({'id': id, 'top': setTop, 'bottom': setBottom, 'pageNum': setPageNum });\n\t\t} else {\n\t\t\tsetsHidden.push({'id': id, 'top': setTop, 'bottom': setBottom, 'pageNum': setPageNum });\n\t\t}\n\t} );\n\n\t$.each(setsHidden, function() {\n\t\tvar $set = $('#' + this.id);\n\t\tif( $set.hasClass( 'is--replaced' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t        self.pageCache[ this.pageNum].html = $set.html();\n\n\t\t$set.css('min-height', ( this.bottom - this.top ) + 'px' )\n\t\t    .addClass('is--replaced')\n\t\t    .empty();\n\t});\n\n\t$.each(setsInView, function() {\n\t\tvar $set = $('#' + this.id);\n\n\t\tif( $set.hasClass('is--replaced') ) {\n\t\t\t$set.css('min-height', '').removeClass('is--replaced');\n\t\t\tif( this.pageNum in self.pageCache ) {\n\t\t\t\t$set.html( self.pageCache[this.pageNum].html );\n\t\t        \tself.body.trigger( 'post-load', self.pageCache[this.pageNum] );\n\t\t\t}\n\t\t}\n\n\t});\n\n\t// Parse number of sets found in view in an attempt to update the URL to match the set that comprises the majority of the window.\n\tif ( 0 == setsInView.length ) {\n\t\tpageNum = -1;\n\t}\n\telse if ( 1 == setsInView.length ) {\n\t\tvar setData = setsInView.pop();\n\n\t\t// If the first set of IS posts is in the same view as the posts loaded in the template by WordPress, determine how much of the view is comprised of IS-loaded posts\n\t\tif ( ( ( windowBottom - setData.top ) / windowSize ) < 0.5 )\n\t\t\tpageNum = -1;\n\t\telse\n\t\t\tpageNum = setData.pageNum;\n\t}\n\telse {\n\t\tvar majorityPercentageInView = 0;\n\n\t\t// Identify the IS set that comprises the majority of the current window and set the URL to it.\n\t\t$.each( setsInView, function( i, setData ) {\n\t\t\tvar topInView     = 0,\n\t\t\t\tbottomInView  = 0,\n\t\t\t\tpercentOfView = 0;\n\n\t\t\t// Figure percentage of view the current set represents\n\t\t\tif ( setData.top > windowTop && setData.top < windowBottom )\n\t\t\t\ttopInView = ( windowBottom - setData.top ) / windowSize;\n\n\t\t\tif ( setData.bottom > windowTop && setData.bottom < windowBottom )\n\t\t\t\tbottomInView = ( setData.bottom - windowTop ) / windowSize;\n\n\t\t\t// Figure out largest percentage of view for current set\n\t\t\tif ( topInView >= bottomInView )\n\t\t\t\tpercentOfView = topInView;\n\t\t\telse if ( bottomInView >= topInView )\n\t\t\t\tpercentOfView = bottomInView;\n\n\t\t\t// Does current set's percentage of view supplant the largest previously-found set?\n\t\t\tif ( percentOfView > majorityPercentageInView ) {\n\t\t\t\tpageNum = setData.pageNum;\n\t\t\t\tmajorityPercentageInView = percentOfView;\n\t\t\t}\n\t\t} );\n\t}\n\n\t// If a page number could be determined, update the URL\n\t// -1 indicates that the original requested URL should be used.\n\tif ( 'number' == typeof pageNum ) {\n\t\tself.updateURL( pageNum );\n\t}\n}\n\n/**\n * Update address bar to reflect archive page URL for a given page number.\n * Checks if URL is different to prevent pollution of browser history.\n */\nScroller.prototype.updateURL = function( page ) {\n\t// IE only supports pushState() in v10 and above, so don't bother if those conditions aren't met.\n\tif ( ! window.history.pushState ) {\n\t\treturn;\n\t}\n\tvar self = this,\n\t\tpageSlug = -1 == page ? self.origURL : window.location.protocol + '//' + self.history.host + self.history.path.replace( /%d/, page ) + self.history.parameters;\n\n\tif ( window.location.href != pageSlug ) {\n\t\thistory.pushState( null, null, pageSlug );\n\t}\n}\n\n/**\n * Pause scrolling.\n */\nScroller.prototype.pause = function() {\n\tthis.disabled = true;\n};\n\n/**\n * Resume scrolling.\n */\nScroller.prototype.resume = function() {\n\tthis.disabled = false;\n};\n\n/**\n * Ready, set, go!\n */\n$( document ).ready( function() {\n\t// Check for our variables\n\tif ( 'object' != typeof infiniteScroll )\n\t\treturn;\n\n\t$( document.body ).addClass( infiniteScroll.settings.body_class );\n\n\t// Set ajaxurl (for brevity)\n\tajaxurl = infiniteScroll.settings.ajaxurl;\n\n\t// Set stats, used for tracking stats\n\tstats = infiniteScroll.settings.stats;\n\n\t// Define what type of infinity we have, grab text for click-handle\n\ttype  = infiniteScroll.settings.type;\n\ttext  = infiniteScroll.settings.text;\n\ttotop = infiniteScroll.settings.totop;\n\n\t// Initialize the scroller (with the ID of the element from the theme)\n\tinfiniteScroll.scroller = new Scroller( infiniteScroll.settings );\n\n\t/**\n\t * Monitor user scroll activity to update URL to correspond to archive page for current set of IS posts\n\t */\n    if( type == 'click' ) {\n        var timer = null;\n        $( window ).bind( 'scroll', function() {\n            // run the real scroll handler once every 250 ms.\n            if ( timer ) { return; }\n            timer = setTimeout( function() {\n                infiniteScroll.scroller.determineURL();\n                timer = null;\n            } , 250 );\n        });\n    }\n\n\t// Integrate with Selective Refresh in the Customizer.\n\tif ( 'undefined' !== typeof wp && wp.customize && wp.customize.selectiveRefresh ) {\n\n\t\t/**\n\t\t * Handle rendering of selective refresh partials.\n\t\t *\n\t\t * Make sure that when a partial is rendered, the Jetpack post-load event\n\t\t * will be triggered so that any dynamic elements will be re-constructed,\n\t\t * such as ME.js elements, Photon replacements, social sharing, and more.\n\t\t * Note that this is applying here not strictly to posts being loaded.\n\t\t * If a widget contains a ME.js element and it is previewed via selective\n\t\t * refresh, the post-load would get triggered allowing any dynamic elements\n\t\t * therein to also be re-constructed.\n\t\t *\n\t\t * @param {wp.customize.selectiveRefresh.Placement} placement\n\t\t */\n\t\twp.customize.selectiveRefresh.bind( 'partial-content-rendered', function( placement ) {\n\t\t\tvar content;\n\t\t\tif ( 'string' === typeof placement.addedContent ) {\n\t\t\t\tcontent = placement.addedContent;\n\t\t\t} else if ( placement.container ) {\n\t\t\t\tcontent = $( placement.container ).html();\n\t\t\t}\n\n\t\t\tif ( content ) {\n\t\t\t\t$( document.body ).trigger( 'post-load', { html: content } );\n\t\t\t}\n\t\t} );\n\n\t\t/*\n\t\t * Add partials for posts added via infinite scroll.\n\t\t *\n\t\t * This is unnecessary when MutationObserver is supported by the browser\n\t\t * since then this will be handled by Selective Refresh in core.\n\t\t */\n\t\tif ( 'undefined' === typeof MutationObserver ) {\n\t\t\t$( document.body ).on( 'post-load', function( e, response ) {\n\t\t\t\tvar rootElement = null;\n\t\t\t\tif ( response.html && -1 !== response.html.indexOf( 'data-customize-partial' ) ) {\n\t\t\t\t\tif ( infiniteScroll.settings.id ) {\n\t\t\t\t\t\trootElement = $( '#' + infiniteScroll.settings.id );\n\t\t\t\t\t}\n\t\t\t\t\twp.customize.selectiveRefresh.addPartials( rootElement );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t}\n});\n\n\n})(jQuery); // Close closure\n"]}