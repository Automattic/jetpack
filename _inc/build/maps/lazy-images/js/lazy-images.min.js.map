{"version":3,"sources":["lazy-images/js/lazy-images.js"],"names":["jetpackLazyImagesModule","$","lazy_load_init","images","document","querySelectorAll","imageCount","length","observer","disconnect","window","IntersectionObserver","onIntersection","config","i","image","getAttribute","observe","loadImagesImmediately","immediateImages","applyImage","entries","entry","intersectionRatio","unobserve","target","srcset","sizes","theClone","theImage","attr","clone","removeAttr","addClass","replaceWith","trigger","rootMargin","threshold","ready","bind","IntersectionObserverEntry","this","time","rootBounds","boundingClientRect","intersectionRect","getEmptyRect","isIntersecting","targetRect","targetArea","width","height","intersectionArea","callback","opt_options","options","Error","root","nodeType","_checkForIntersections","throttle","THROTTLE_TIMEOUT","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","thresholds","_initThresholds","map","margin","value","unit","join","now","performance","fn","timeout","timer","setTimeout","addEvent","node","event","opt_useCapture","addEventListener","attachEvent","removeEvent","removeEventListener","detatchEvent","computeRectIntersection","rect1","rect2","top","Math","max","bottom","min","left","right","getBoundingClientRect","el","rect","err","containsDeep","parent","child","getParentNode","parentNode","host","prototype","Object","defineProperty","get","registry","POLL_INTERVAL","USE_MUTATION_OBSERVER","some","item","element","_registerInstance","push","_monitorIntersections","filter","_unmonitorIntersections","_unregisterInstance","takeRecords","records","slice","opt_threshold","Array","isArray","sort","t","a","isNaN","opt_rootMargin","marginString","margins","split","parts","exec","parseFloat","_monitoringIntersections","_monitoringInterval","setInterval","_domObserver","MutationObserver","attributes","childList","characterData","subtree","clearInterval","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","forEach","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","_hasCrossedThreshold","getComputedStyle","display","atRoot","parentRect","parentComputedStyle","body","documentElement","overflow","html","clientWidth","clientHeight","_expandRectByRootMargin","newRect","oldRatio","newRatio","indexOf","index","splice","jQuery"],"mappings":"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","file":"../../../lazy-images/js/lazy-images.min.js","sourcesContent":["/* Do not modify this file directly. It is compiled from other files. */\n/* globals IntersectionObserver, jQuery */\n\nvar jetpackLazyImagesModule = function( $ ) {\n\tvar images,\n\t\tconfig = {\n\t\t\t// If the image gets within 200px in the Y axis, start the download.\n\t\t\trootMargin: '200px 0px',\n\t\t\tthreshold: 0.01\n\t\t},\n\t\timageCount = 0,\n\t\tobserver,\n\t\timage,\n\t\ti;\n\n\t$( document ).ready( function() {\n\t\tlazy_load_init();\n\n\t\t// Lazy load images that are brought in from Infinite Scroll\n\t\t$( 'body' ).bind( 'post-load', lazy_load_init );\n\n\t\t// Add event to provide optional compatibility for other code.\n\t\t$( 'body' ).bind( 'jetpack-lazy-images-load', lazy_load_init );\n\t} );\n\n\tfunction lazy_load_init() {\n\t\timages = document.querySelectorAll( 'img.jetpack-lazy-image:not(.jetpack-lazy-image--handled)' );\n\t\timageCount = images.length;\n\n\t\t// If initialized, then disconnect the observer\n\t\tif ( observer ) {\n\t\t\tobserver.disconnect();\n\t\t}\n\n\t\t// If we don't have support for intersection observer, loads the images immediately\n\t\tif ( ! ( 'IntersectionObserver' in window ) ) {\n\t\t\tloadImagesImmediately( images );\n\t\t} else {\n\t\t\t// It is supported, load the images\n\t\t\tobserver = new IntersectionObserver( onIntersection, config );\n\n\t\t\t// foreach() is not supported in IE\n\t\t\tfor ( i = 0; i < images.length; i++ ) {\n\t\t\t\timage = images[ i ];\n\t\t\t\tif ( image.getAttribute( 'data-lazy-loaded' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tobserver.observe( image );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Load all of the images immediately\n\t * @param {NodeListOf<Element>} immediateImages List of lazy-loaded images to load immediately.\n\t */\n\tfunction loadImagesImmediately( immediateImages ) {\n\t\tvar i;\n\n\t\t// foreach() is not supported in IE\n\t\tfor ( i = 0; i < immediateImages.length; i++ ) {\n\t\t\tvar image = immediateImages[ i ];\n\t\t\tapplyImage( image );\n\t\t}\n\t}\n\n\t/**\n\t * On intersection\n\t * @param {array} entries List of elements being observed.\n\t */\n\tfunction onIntersection( entries ) {\n\t\tvar i;\n\n\t\t// Disconnect if we've already loaded all of the images\n\t\tif ( imageCount === 0 ) {\n\t\t\tobserver.disconnect();\n\t\t}\n\n\t\t// Loop through the entries\n\t\tfor ( i = 0; i < entries.length; i++ ) {\n\t\t\tvar entry = entries[ i ];\n\n\t\t\t// Are we in viewport?\n\t\t\tif ( entry.intersectionRatio > 0 ) {\n\t\t\t\timageCount--;\n\n\t\t\t\t// Stop watching and load the image\n\t\t\t\tobserver.unobserve( entry.target );\n\t\t\t\tapplyImage( entry.target );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Apply the image\n\t * @param {object} image The image object.\n\t */\n\tfunction applyImage( image ) {\n\t\tvar theImage = $( image ),\n\t\t\tsrcset,\n\t\t\tsizes,\n\t\t\ttheClone;\n\n\t\tif ( ! theImage.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tsrcset = theImage.attr( 'data-lazy-srcset' );\n\t\tsizes = theImage.attr( 'data-lazy-sizes' );\n\t\ttheClone = theImage.clone();\n\n\t\t// Remove lazy attributes from the clone.\n\t\ttheClone.removeAttr( 'data-lazy-srcset' ),\n\t\ttheClone.removeAttr( 'data-lazy-sizes' );\n\t\ttheClone.removeAttr( 'data-lazy-src' );\n\n\t\t// Add the attributes we want on the finished image.\n\t\ttheClone.addClass( 'jetpack-lazy-image--handled' );\n\t\ttheClone.attr( 'data-lazy-loaded', 1 );\n\t\tif ( ! srcset ) {\n\t\t\ttheClone.removeAttr( 'srcset' );\n\t\t} else {\n\t\t\ttheClone.attr( 'srcset', srcset );\n\t\t}\n\t\tif ( sizes ) {\n\t\t\ttheClone.attr( 'sizes', sizes );\n\t\t}\n\n\t\ttheImage.replaceWith( theClone );\n\n\t\t// Fire an event so that third-party code can perform actions after an image is loaded.\n\t\ttheClone.trigger( 'jetpack-lazy-loaded-image' );\n\t}\n};\n\n/**\n * The following is an Intersection observer polyfill which is licensed under\n * the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE and can be found at:\n * https://github.com/w3c/IntersectionObserver/tree/master/polyfill\n */\n\n/* jshint ignore:start */\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n\n(function(window, document) {\n\t'use strict';\n\n\n\t// Exits early if all IntersectionObserver and IntersectionObserverEntry\n\t// features are natively supported.\n\tif ('IntersectionObserver' in window &&\n\t\t'IntersectionObserverEntry' in window &&\n\t\t'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\n\t  // Minimal polyfill for Edge 15's lack of `isIntersecting`\n\t  // See: https://github.com/w3c/IntersectionObserver/issues/211\n\t  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n\t\tObject.defineProperty(window.IntersectionObserverEntry.prototype,\n\t\t  'isIntersecting', {\n\t\t  get: function () {\n\t\t\treturn this.intersectionRatio > 0;\n\t\t  }\n\t\t});\n\t  }\n\t  return;\n\t}\n\n\n\t/**\n\t * An IntersectionObserver registry. This registry exists to hold a strong\n\t * reference to IntersectionObserver instances currently observering a target\n\t * element. Without this registry, instances without another reference may be\n\t * garbage collected.\n\t */\n\tvar registry = [];\n\n\n\t/**\n\t * Creates the global IntersectionObserverEntry constructor.\n\t * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n\t * @param {Object} entry A dictionary of instance properties.\n\t * @constructor\n\t */\n\tfunction IntersectionObserverEntry(entry) {\n\t  this.time = entry.time;\n\t  this.target = entry.target;\n\t  this.rootBounds = entry.rootBounds;\n\t  this.boundingClientRect = entry.boundingClientRect;\n\t  this.intersectionRect = entry.intersectionRect || getEmptyRect();\n\t  this.isIntersecting = !!entry.intersectionRect;\n\n\t  // Calculates the intersection ratio.\n\t  var targetRect = this.boundingClientRect;\n\t  var targetArea = targetRect.width * targetRect.height;\n\t  var intersectionRect = this.intersectionRect;\n\t  var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n\t  // Sets intersection ratio.\n\t  if (targetArea) {\n\t\tthis.intersectionRatio = intersectionArea / targetArea;\n\t  } else {\n\t\t// If area is zero and is intersecting, sets to 1, otherwise to 0\n\t\tthis.intersectionRatio = this.isIntersecting ? 1 : 0;\n\t  }\n\t}\n\n\n\t/**\n\t * Creates the global IntersectionObserver constructor.\n\t * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n\t * @param {Function} callback The function to be invoked after intersection\n\t *     changes have queued. The function is not invoked if the queue has\n\t *     been emptied by calling the `takeRecords` method.\n\t * @param {Object=} opt_options Optional configuration options.\n\t * @constructor\n\t */\n\tfunction IntersectionObserver(callback, opt_options) {\n\n\t  var options = opt_options || {};\n\n\t  if (typeof callback != 'function') {\n\t\tthrow new Error('callback must be a function');\n\t  }\n\n\t  if (options.root && options.root.nodeType != 1) {\n\t\tthrow new Error('root must be an Element');\n\t  }\n\n\t  // Binds and throttles `this._checkForIntersections`.\n\t  this._checkForIntersections = throttle(\n\t\t  this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n\t  // Private properties.\n\t  this._callback = callback;\n\t  this._observationTargets = [];\n\t  this._queuedEntries = [];\n\t  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n\t  // Public properties.\n\t  this.thresholds = this._initThresholds(options.threshold);\n\t  this.root = options.root || null;\n\t  this.rootMargin = this._rootMarginValues.map(function(margin) {\n\t\treturn margin.value + margin.unit;\n\t  }).join(' ');\n\t}\n\n\n\t/**\n\t * The minimum interval within which the document will be checked for\n\t * intersection changes.\n\t */\n\tIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n\t/**\n\t * The frequency in which the polyfill polls for intersection changes.\n\t * this can be updated on a per instance basis and must be set prior to\n\t * calling `observe` on the first target.\n\t */\n\tIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n\t/**\n\t * Use a mutation observer on the root element\n\t * to detect intersection changes.\n\t */\n\tIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n\n\t/**\n\t * Starts observing a target element for intersection changes based on\n\t * the thresholds values.\n\t * @param {Element} target The DOM element to observe.\n\t */\n\tIntersectionObserver.prototype.observe = function(target) {\n\t  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n\t\treturn item.element == target;\n\t  });\n\n\t  if (isTargetAlreadyObserved) {\n\t\treturn;\n\t  }\n\n\t  if (!(target && target.nodeType == 1)) {\n\t\tthrow new Error('target must be an Element');\n\t  }\n\n\t  this._registerInstance();\n\t  this._observationTargets.push({element: target, entry: null});\n\t  this._monitorIntersections();\n\t  this._checkForIntersections();\n\t};\n\n\n\t/**\n\t * Stops observing a target element for intersection changes.\n\t * @param {Element} target The DOM element to observe.\n\t */\n\tIntersectionObserver.prototype.unobserve = function(target) {\n\t  this._observationTargets =\n\t\t  this._observationTargets.filter(function(item) {\n\n\t\treturn item.element != target;\n\t  });\n\t  if (!this._observationTargets.length) {\n\t\tthis._unmonitorIntersections();\n\t\tthis._unregisterInstance();\n\t  }\n\t};\n\n\n\t/**\n\t * Stops observing all target elements for intersection changes.\n\t */\n\tIntersectionObserver.prototype.disconnect = function() {\n\t  this._observationTargets = [];\n\t  this._unmonitorIntersections();\n\t  this._unregisterInstance();\n\t};\n\n\n\t/**\n\t * Returns any queue entries that have not yet been reported to the\n\t * callback and clears the queue. This can be used in conjunction with the\n\t * callback to obtain the absolute most up-to-date intersection information.\n\t * @return {Array} The currently queued entries.\n\t */\n\tIntersectionObserver.prototype.takeRecords = function() {\n\t  var records = this._queuedEntries.slice();\n\t  this._queuedEntries = [];\n\t  return records;\n\t};\n\n\n\t/**\n\t * Accepts the threshold value from the user configuration object and\n\t * returns a sorted array of unique threshold values. If a value is not\n\t * between 0 and 1 and error is thrown.\n\t * @private\n\t * @param {Array|number=} opt_threshold An optional threshold value or\n\t *     a list of threshold values, defaulting to [0].\n\t * @return {Array} A sorted list of unique and valid threshold values.\n\t */\n\tIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n\t  var threshold = opt_threshold || [0];\n\t  if (!Array.isArray(threshold)) threshold = [threshold];\n\n\t  return threshold.sort().filter(function(t, i, a) {\n\t\tif (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n\t\t  throw new Error('threshold must be a number between 0 and 1 inclusively');\n\t\t}\n\t\treturn t !== a[i - 1];\n\t  });\n\t};\n\n\n\t/**\n\t * Accepts the rootMargin value from the user configuration object\n\t * and returns an array of the four margin values as an object containing\n\t * the value and unit properties. If any of the values are not properly\n\t * formatted or use a unit other than px or %, and error is thrown.\n\t * @private\n\t * @param {string=} opt_rootMargin An optional rootMargin value,\n\t *     defaulting to '0px'.\n\t * @return {Array<Object>} An array of margin objects with the keys\n\t *     value and unit.\n\t */\n\tIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n\t  var marginString = opt_rootMargin || '0px';\n\t  var margins = marginString.split(/\\s+/).map(function(margin) {\n\t\tvar parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n\t\tif (!parts) {\n\t\t  throw new Error('rootMargin must be specified in pixels or percent');\n\t\t}\n\t\treturn {value: parseFloat(parts[1]), unit: parts[2]};\n\t  });\n\n\t  // Handles shorthand.\n\t  margins[1] = margins[1] || margins[0];\n\t  margins[2] = margins[2] || margins[0];\n\t  margins[3] = margins[3] || margins[1];\n\n\t  return margins;\n\t};\n\n\n\t/**\n\t * Starts polling for intersection changes if the polling is not already\n\t * happening, and if the page's visibilty state is visible.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._monitorIntersections = function() {\n\t  if (!this._monitoringIntersections) {\n\t\tthis._monitoringIntersections = true;\n\n\t\t// If a poll interval is set, use polling instead of listening to\n\t\t// resize and scroll events or DOM mutations.\n\t\tif (this.POLL_INTERVAL) {\n\t\t  this._monitoringInterval = setInterval(\n\t\t\t  this._checkForIntersections, this.POLL_INTERVAL);\n\t\t}\n\t\telse {\n\t\t  addEvent(window, 'resize', this._checkForIntersections, true);\n\t\t  addEvent(document, 'scroll', this._checkForIntersections, true);\n\n\t\t  if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\n\t\t\tthis._domObserver = new MutationObserver(this._checkForIntersections);\n\t\t\tthis._domObserver.observe(document, {\n\t\t\t  attributes: true,\n\t\t\t  childList: true,\n\t\t\t  characterData: true,\n\t\t\t  subtree: true\n\t\t\t});\n\t\t  }\n\t\t}\n\t  }\n\t};\n\n\n\t/**\n\t * Stops polling for intersection changes.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._unmonitorIntersections = function() {\n\t  if (this._monitoringIntersections) {\n\t\tthis._monitoringIntersections = false;\n\n\t\tclearInterval(this._monitoringInterval);\n\t\tthis._monitoringInterval = null;\n\n\t\tremoveEvent(window, 'resize', this._checkForIntersections, true);\n\t\tremoveEvent(document, 'scroll', this._checkForIntersections, true);\n\n\t\tif (this._domObserver) {\n\t\t  this._domObserver.disconnect();\n\t\t  this._domObserver = null;\n\t\t}\n\t  }\n\t};\n\n\n\t/**\n\t * Scans each observation target for intersection changes and adds them\n\t * to the internal entries queue. If new entries are found, it\n\t * schedules the callback to be invoked.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._checkForIntersections = function() {\n\t  var rootIsInDom = this._rootIsInDom();\n\t  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n\t  this._observationTargets.forEach(function(item) {\n\t\tvar target = item.element;\n\t\tvar targetRect = getBoundingClientRect(target);\n\t\tvar rootContainsTarget = this._rootContainsTarget(target);\n\t\tvar oldEntry = item.entry;\n\t\tvar intersectionRect = rootIsInDom && rootContainsTarget &&\n\t\t\tthis._computeTargetAndRootIntersection(target, rootRect);\n\n\t\tvar newEntry = item.entry = new IntersectionObserverEntry({\n\t\t  time: now(),\n\t\t  target: target,\n\t\t  boundingClientRect: targetRect,\n\t\t  rootBounds: rootRect,\n\t\t  intersectionRect: intersectionRect\n\t\t});\n\n\t\tif (!oldEntry) {\n\t\t  this._queuedEntries.push(newEntry);\n\t\t} else if (rootIsInDom && rootContainsTarget) {\n\t\t  // If the new entry intersection ratio has crossed any of the\n\t\t  // thresholds, add a new entry.\n\t\t  if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n\t\t\tthis._queuedEntries.push(newEntry);\n\t\t  }\n\t\t} else {\n\t\t  // If the root is not in the DOM or target is not contained within\n\t\t  // root but the previous entry for this target had an intersection,\n\t\t  // add a new record indicating removal.\n\t\t  if (oldEntry && oldEntry.isIntersecting) {\n\t\t\tthis._queuedEntries.push(newEntry);\n\t\t  }\n\t\t}\n\t  }, this);\n\n\t  if (this._queuedEntries.length) {\n\t\tthis._callback(this.takeRecords(), this);\n\t  }\n\t};\n\n\n\t/**\n\t * Accepts a target and root rect computes the intersection between then\n\t * following the algorithm in the spec.\n\t * TODO(philipwalton): at this time clip-path is not considered.\n\t * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n\t * @param {Element} target The target DOM element\n\t * @param {Object} rootRect The bounding rect of the root after being\n\t *     expanded by the rootMargin value.\n\t * @return {?Object} The final intersection rect object or undefined if no\n\t *     intersection is found.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._computeTargetAndRootIntersection =\n\t\tfunction(target, rootRect) {\n\n\t  // If the element isn't displayed, an intersection can't happen.\n\t  if (window.getComputedStyle(target).display == 'none') return;\n\n\t  var targetRect = getBoundingClientRect(target);\n\t  var intersectionRect = targetRect;\n\t  var parent = getParentNode(target);\n\t  var atRoot = false;\n\n\t  while (!atRoot) {\n\t\tvar parentRect = null;\n\t\tvar parentComputedStyle = parent.nodeType == 1 ?\n\t\t\twindow.getComputedStyle(parent) : {};\n\n\t\t// If the parent isn't displayed, an intersection can't happen.\n\t\tif (parentComputedStyle.display == 'none') return;\n\n\t\tif (parent == this.root || parent == document) {\n\t\t  atRoot = true;\n\t\t  parentRect = rootRect;\n\t\t} else {\n\t\t  // If the element has a non-visible overflow, and it's not the <body>\n\t\t  // or <html> element, update the intersection rect.\n\t\t  // Note: <body> and <html> cannot be clipped to a rect that's not also\n\t\t  // the document rect, so no need to compute a new intersection.\n\t\t  if (parent != document.body &&\n\t\t\t  parent != document.documentElement &&\n\t\t\t  parentComputedStyle.overflow != 'visible') {\n\t\t\tparentRect = getBoundingClientRect(parent);\n\t\t  }\n\t\t}\n\n\t\t// If either of the above conditionals set a new parentRect,\n\t\t// calculate new intersection data.\n\t\tif (parentRect) {\n\t\t  intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n\t\t  if (!intersectionRect) break;\n\t\t}\n\t\tparent = getParentNode(parent);\n\t  }\n\t  return intersectionRect;\n\t};\n\n\n\t/**\n\t * Returns the root rect after being expanded by the rootMargin value.\n\t * @return {Object} The expanded root rect.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._getRootRect = function() {\n\t  var rootRect;\n\t  if (this.root) {\n\t\trootRect = getBoundingClientRect(this.root);\n\t  } else {\n\t\t// Use <html>/<body> instead of window since scroll bars affect size.\n\t\tvar html = document.documentElement;\n\t\tvar body = document.body;\n\t\trootRect = {\n\t\t  top: 0,\n\t\t  left: 0,\n\t\t  right: html.clientWidth || body.clientWidth,\n\t\t  width: html.clientWidth || body.clientWidth,\n\t\t  bottom: html.clientHeight || body.clientHeight,\n\t\t  height: html.clientHeight || body.clientHeight\n\t\t};\n\t  }\n\t  return this._expandRectByRootMargin(rootRect);\n\t};\n\n\n\t/**\n\t * Accepts a rect and expands it by the rootMargin value.\n\t * @param {Object} rect The rect object to expand.\n\t * @return {Object} The expanded rect.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n\t  var margins = this._rootMarginValues.map(function(margin, i) {\n\t\treturn margin.unit == 'px' ? margin.value :\n\t\t\tmargin.value * (i % 2 ? rect.width : rect.height) / 100;\n\t  });\n\t  var newRect = {\n\t\ttop: rect.top - margins[0],\n\t\tright: rect.right + margins[1],\n\t\tbottom: rect.bottom + margins[2],\n\t\tleft: rect.left - margins[3]\n\t  };\n\t  newRect.width = newRect.right - newRect.left;\n\t  newRect.height = newRect.bottom - newRect.top;\n\n\t  return newRect;\n\t};\n\n\n\t/**\n\t * Accepts an old and new entry and returns true if at least one of the\n\t * threshold values has been crossed.\n\t * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n\t *    particular target element or null if no previous entry exists.\n\t * @param {IntersectionObserverEntry} newEntry The current entry for a\n\t *    particular target element.\n\t * @return {boolean} Returns true if a any threshold has been crossed.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._hasCrossedThreshold =\n\t\tfunction(oldEntry, newEntry) {\n\n\t  // To make comparing easier, an entry that has a ratio of 0\n\t  // but does not actually intersect is given a value of -1\n\t  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n\t\t  oldEntry.intersectionRatio || 0 : -1;\n\t  var newRatio = newEntry.isIntersecting ?\n\t\t  newEntry.intersectionRatio || 0 : -1;\n\n\t  // Ignore unchanged ratios\n\t  if (oldRatio === newRatio) return;\n\n\t  for (var i = 0; i < this.thresholds.length; i++) {\n\t\tvar threshold = this.thresholds[i];\n\n\t\t// Return true if an entry matches a threshold or if the new ratio\n\t\t// and the old ratio are on the opposite sides of a threshold.\n\t\tif (threshold == oldRatio || threshold == newRatio ||\n\t\t\tthreshold < oldRatio !== threshold < newRatio) {\n\t\t  return true;\n\t\t}\n\t  }\n\t};\n\n\n\t/**\n\t * Returns whether or not the root element is an element and is in the DOM.\n\t * @return {boolean} True if the root element is an element and is in the DOM.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._rootIsInDom = function() {\n\t  return !this.root || containsDeep(document, this.root);\n\t};\n\n\n\t/**\n\t * Returns whether or not the target element is a child of root.\n\t * @param {Element} target The target element to check.\n\t * @return {boolean} True if the target element is a child of root.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._rootContainsTarget = function(target) {\n\t  return containsDeep(this.root || document, target);\n\t};\n\n\n\t/**\n\t * Adds the instance to the global IntersectionObserver registry if it isn't\n\t * already present.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._registerInstance = function() {\n\t  if (registry.indexOf(this) < 0) {\n\t\tregistry.push(this);\n\t  }\n\t};\n\n\n\t/**\n\t * Removes the instance from the global IntersectionObserver registry.\n\t * @private\n\t */\n\tIntersectionObserver.prototype._unregisterInstance = function() {\n\t  var index = registry.indexOf(this);\n\t  if (index != -1) registry.splice(index, 1);\n\t};\n\n\n\t/**\n\t * Returns the result of the performance.now() method or null in browsers\n\t * that don't support the API.\n\t * @return {number} The elapsed time since the page was requested.\n\t */\n\tfunction now() {\n\t  return window.performance && performance.now && performance.now();\n\t}\n\n\n\t/**\n\t * Throttles a function and delays its executiong, so it's only called at most\n\t * once within a given time period.\n\t * @param {Function} fn The function to throttle.\n\t * @param {number} timeout The amount of time that must pass before the\n\t *     function can be called again.\n\t * @return {Function} The throttled function.\n\t */\n\tfunction throttle(fn, timeout) {\n\t  var timer = null;\n\t  return function () {\n\t\tif (!timer) {\n\t\t  timer = setTimeout(function() {\n\t\t\tfn();\n\t\t\ttimer = null;\n\t\t  }, timeout);\n\t\t}\n\t  };\n\t}\n\n\n\t/**\n\t * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n\t * @param {Node} node The DOM node to add the event handler to.\n\t * @param {string} event The event name.\n\t * @param {Function} fn The event handler to add.\n\t * @param {boolean} opt_useCapture Optionally adds the even to the capture\n\t *     phase. Note: this only works in modern browsers.\n\t */\n\tfunction addEvent(node, event, fn, opt_useCapture) {\n\t  if (typeof node.addEventListener == 'function') {\n\t\tnode.addEventListener(event, fn, opt_useCapture || false);\n\t  }\n\t  else if (typeof node.attachEvent == 'function') {\n\t\tnode.attachEvent('on' + event, fn);\n\t  }\n\t}\n\n\n\t/**\n\t * Removes a previously added event handler from a DOM node.\n\t * @param {Node} node The DOM node to remove the event handler from.\n\t * @param {string} event The event name.\n\t * @param {Function} fn The event handler to remove.\n\t * @param {boolean} opt_useCapture If the event handler was added with this\n\t *     flag set to true, it should be set to true here in order to remove it.\n\t */\n\tfunction removeEvent(node, event, fn, opt_useCapture) {\n\t  if (typeof node.removeEventListener == 'function') {\n\t\tnode.removeEventListener(event, fn, opt_useCapture || false);\n\t  }\n\t  else if (typeof node.detatchEvent == 'function') {\n\t\tnode.detatchEvent('on' + event, fn);\n\t  }\n\t}\n\n\n\t/**\n\t * Returns the intersection between two rect objects.\n\t * @param {Object} rect1 The first rect.\n\t * @param {Object} rect2 The second rect.\n\t * @return {?Object} The intersection rect or undefined if no intersection\n\t *     is found.\n\t */\n\tfunction computeRectIntersection(rect1, rect2) {\n\t  var top = Math.max(rect1.top, rect2.top);\n\t  var bottom = Math.min(rect1.bottom, rect2.bottom);\n\t  var left = Math.max(rect1.left, rect2.left);\n\t  var right = Math.min(rect1.right, rect2.right);\n\t  var width = right - left;\n\t  var height = bottom - top;\n\n\t  return (width >= 0 && height >= 0) && {\n\t\ttop: top,\n\t\tbottom: bottom,\n\t\tleft: left,\n\t\tright: right,\n\t\twidth: width,\n\t\theight: height\n\t  };\n\t}\n\n\n\t/**\n\t * Shims the native getBoundingClientRect for compatibility with older IE.\n\t * @param {Element} el The element whose bounding rect to get.\n\t * @return {Object} The (possibly shimmed) rect of the element.\n\t */\n\tfunction getBoundingClientRect(el) {\n\t  var rect;\n\n\t  try {\n\t\trect = el.getBoundingClientRect();\n\t  } catch (err) {\n\t\t// Ignore Windows 7 IE11 \"Unspecified error\"\n\t\t// https://github.com/w3c/IntersectionObserver/pull/205\n\t  }\n\n\t  if (!rect) return getEmptyRect();\n\n\t  // Older IE\n\t  if (!(rect.width && rect.height)) {\n\t\trect = {\n\t\t  top: rect.top,\n\t\t  right: rect.right,\n\t\t  bottom: rect.bottom,\n\t\t  left: rect.left,\n\t\t  width: rect.right - rect.left,\n\t\t  height: rect.bottom - rect.top\n\t\t};\n\t  }\n\t  return rect;\n\t}\n\n\n\t/**\n\t * Returns an empty rect object. An empty rect is returned when an element\n\t * is not in the DOM.\n\t * @return {Object} The empty rect.\n\t */\n\tfunction getEmptyRect() {\n\t  return {\n\t\ttop: 0,\n\t\tbottom: 0,\n\t\tleft: 0,\n\t\tright: 0,\n\t\twidth: 0,\n\t\theight: 0\n\t  };\n\t}\n\n\t/**\n\t * Checks to see if a parent element contains a child elemnt (including inside\n\t * shadow DOM).\n\t * @param {Node} parent The parent element.\n\t * @param {Node} child The child element.\n\t * @return {boolean} True if the parent node contains the child node.\n\t */\n\tfunction containsDeep(parent, child) {\n\t  var node = child;\n\t  while (node) {\n\t\tif (node == parent) return true;\n\n\t\tnode = getParentNode(node);\n\t  }\n\t  return false;\n\t}\n\n\n\t/**\n\t * Gets the parent node of an element or its host element if the parent node\n\t * is a shadow root.\n\t * @param {Node} node The node whose parent to get.\n\t * @return {Node|null} The parent node or null if no parent exists.\n\t */\n\tfunction getParentNode(node) {\n\t  var parent = node.parentNode;\n\n\t  if (parent && parent.nodeType == 11 && parent.host) {\n\t\t// If the parent is a shadow root, return the host element.\n\t\treturn parent.host;\n\t  }\n\t  return parent;\n\t}\n\n\n\t// Exposes the constructors globally.\n\twindow.IntersectionObserver = IntersectionObserver;\n\twindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n\t}(window, document));\n/* jshint ignore:end */\n\n// Let's kick things off now\njetpackLazyImagesModule( jQuery );\n"]}