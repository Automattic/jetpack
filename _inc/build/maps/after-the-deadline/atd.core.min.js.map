{"version":3,"sources":["after-the-deadline/atd.core.js"],"names":["AtDCore","this","ignore_types","ignore_strings","i18n","TokenIterator","tokens","index","count","last","atd_sprintf","format","values","result","x","length","replace","RegExp","EXPORTED_SYMBOLS","prototype","getLang","key","defaultk","window","AtD_l10n_r0ar","addI18n","obj","setIgnoreStrings","string","parent","map","split","showTypes","show_types","types","undefined","push","makeError","error_s","type","seps","struct","test","regexp","used","addToErrorStructure","errors","list","error","pre","first","pretoks","defaults","buildErrorStructure","spellingList","enrichmentList","grammarList","_getSeparators","i","re","str","charAt","processXML","responseXML","suggestions","getElementsByTagName","grammarErrors","spellingErrors","enrichment","item","firstChild","errorContext","errorString","data","errorType","errorDescription","suggestion","j","errorUrl","word","errorStruct","ecount","findSuggestion","element","text","innerHTML","context","getAttrib","alert","len","next","current","substring","hasNext","hasNextN","n","skip","m","getCount","peek","peepers","end","markMyWords","container_nodes","splitTextNode","textnode","replacement","cursor","nodeValue","search","match","captured","document","createTextNode","substr","create","_isInPre","node","parentNode","nodeName","textOnlyMode","nl","bogus","_isTinyMCE","emptySpan","_walk","nodeType","isMarkedNode","iterator","v","previous","doReplaces","token","prev","curr","done","checkErrors","foundStrings","newNode","span","splitNodes","isIE","appendChild","remove","contents","y","nnode","replaceWith","removeParent","elements","f","call","removeWords","w","findSpans","reverse","hasClass","isEmptySpan","applySuggestion","hasErrorMessage","xmlr","getErrorMessage","navigator","appName"],"mappings":"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","file":"../../after-the-deadline/atd.core.min.js","sourcesContent":["/* Do not modify this file directly. It is compiled from other files. */\n/*\n * atd.core.js - A building block to create a front-end for AtD\n * Author      : Raphael Mudge, Automattic\n * License     : LGPL\n * Project     : http://www.afterthedeadline.com/developers.slp\n * Contact     : raffi@automattic.com\n */\n\n/* jshint sub: true, devel: true, onevar: false, smarttabs: true, loopfunc: true */\n/* exported EXPORTED_SYMBOLS, atd_sprintf */\n\n/* EXPORTED_SYMBOLS is set so this file can be a JavaScript Module */\nvar EXPORTED_SYMBOLS = ['AtDCore'];\n\nfunction AtDCore() {\n\t/* these are the categories of errors AtD should ignore */\n\tthis.ignore_types = ['Bias Language', 'Cliches', 'Complex Expression', 'Diacritical Marks', 'Double Negatives', 'Hidden Verbs', 'Jargon Language', 'Passive voice', 'Phrases to Avoid', 'Redundant Expression'];\n\n\t/* these are the phrases AtD should ignore */\n\tthis.ignore_strings = {};\n\n\t/* Localized strings */\n\t// Back-compat, not used\n\tthis.i18n = {};\n}\n\n/*\n * Internationalization Functions\n */\n\nAtDCore.prototype.getLang = function( key, defaultk ) {\n\treturn ( window.AtD_l10n_r0ar && window.AtD_l10n_r0ar[key] ) || defaultk;\n};\n\nAtDCore.prototype.addI18n = function( obj ) {\n\t// Back-compat\n\twindow.AtD_l10n_r0ar = obj;\n};\n\n/*\n * Setters\n */\n\nAtDCore.prototype.setIgnoreStrings = function(string) {\n\tvar parent = this;\n\n\tthis.map(string.split(/,\\s*/g), function(string) {\n\t\tparent.ignore_strings[string] = 1;\n\t});\n};\n\nAtDCore.prototype.showTypes = function(string) {\n\tvar show_types = string.split(/,\\s*/g);\n\tvar types = {};\n\n\t/* set some default types that we want to make optional */\n\n\t\t/* grammar checker options */\n\ttypes['Double Negatives']     = 1;\n\ttypes['Hidden Verbs']         = 1;\n\ttypes['Passive voice']        = 1;\n\ttypes['Bias Language']        = 1;\n\n\t\t/* style checker options */\n\ttypes['Cliches']              = 1;\n\ttypes['Complex Expression']   = 1;\n\ttypes['Diacritical Marks']    = 1;\n\ttypes['Jargon Language']      = 1;\n\ttypes['Phrases to Avoid']     = 1;\n\ttypes['Redundant Expression'] = 1;\n\n        var ignore_types = [];\n\n        this.map(show_types, function(string) {\n                types[string] = undefined;\n        });\n\n        this.map(this.ignore_types, function(string) {\n                if (types[string] !== undefined) {\n                        ignore_types.push(string);\n\t\t}\n        });\n\n        this.ignore_types = ignore_types;\n};\n\n/*\n * Error Parsing Code\n */\n\nAtDCore.prototype.makeError = function(error_s, tokens, type, seps/*, pre*/) {\n\tvar struct = {};\n\tstruct.type = type;\n\tstruct.string = error_s;\n\tstruct.tokens = tokens;\n\n\tif (new RegExp('\\\\b' + error_s + '\\\\b').test(error_s)) {\n\t\tstruct.regexp = new RegExp('(?!'+error_s+'<)\\\\b' + error_s.replace(/\\s+/g, seps) + '\\\\b');\n\t}\n\telse if (new RegExp(error_s + '\\\\b').test(error_s)) {\n\t\tstruct.regexp = new RegExp('(?!'+error_s+'<)' + error_s.replace(/\\s+/g, seps) + '\\\\b');\n\t}\n\telse if (new RegExp('\\\\b' + error_s).test(error_s)) {\n\t\tstruct.regexp = new RegExp('(?!'+error_s+'<)\\\\b' + error_s.replace(/\\s+/g, seps));\n\t}\n\telse {\n\t\tstruct.regexp = new RegExp('(?!'+error_s+'<)' + error_s.replace(/\\s+/g, seps));\n\t}\n\n\tstruct.used   = false; /* flag whether we've used this rule or not */\n\n\treturn struct;\n};\n\nAtDCore.prototype.addToErrorStructure = function(errors, list, type, seps) {\n\tvar parent = this;\n\n\tthis.map(list, function(error) {\n\t\tvar tokens = error['word'].split(/\\s+/);\n\t\tvar pre    = error['pre'];\n\t\tvar first  = tokens[0];\n\n\t\tif (errors['__' + first] === undefined) {\n\t\t\terrors['__' + first] = {};\n\t\t\terrors['__' + first].pretoks  = {};\n\t\t\terrors['__' + first].defaults = [];\n\t\t}\n\n\t\tif (pre === '') {\n\t\t\terrors['__' + first].defaults.push(parent.makeError(error['word'], tokens, type, seps, pre));\n\t\t} else {\n\t\t\tif (errors['__' + first].pretoks['__' + pre] === undefined) {\n\t\t\t\terrors['__' + first].pretoks['__' + pre] = [];\n\t\t\t}\n\n\t\t\terrors['__' + first].pretoks['__' + pre].push(parent.makeError(error['word'], tokens, type, seps, pre));\n\t\t}\n\t});\n};\n\nAtDCore.prototype.buildErrorStructure = function(spellingList, enrichmentList, grammarList) {\n\tvar seps   = this._getSeparators();\n\tvar errors = {};\n\n\tthis.addToErrorStructure(errors, spellingList, 'hiddenSpellError', seps);\n\tthis.addToErrorStructure(errors, grammarList, 'hiddenGrammarError', seps);\n\tthis.addToErrorStructure(errors, enrichmentList, 'hiddenSuggestion', seps);\n\treturn errors;\n};\n\nAtDCore.prototype._getSeparators = function() {\n\tvar re = '', i;\n\tvar str = '\"s!#$%&()*+,./:;<=>?@[\\\\]^_{|}';\n\n\t// Build word separator regexp\n\tfor (i=0; i<str.length; i++) {\n\t\tre += '\\\\' + str.charAt(i);\n\t}\n\n\treturn '(?:(?:[\\xa0' + re  + '])|(?:\\\\-\\\\-))+';\n};\n\nAtDCore.prototype.processXML = function(responseXML) {\n\n\t/* types of errors to ignore */\n\tvar types = {};\n\n\tthis.map(this.ignore_types, function(type) {\n\t\ttypes[type] = 1;\n\t});\n\n\t/* save suggestions in the editor object */\n\tthis.suggestions = [];\n\n\t/* process through the errors */\n\tvar errors = responseXML.getElementsByTagName('error');\n\n\t/* words to mark */\n\tvar grammarErrors    = [];\n\tvar spellingErrors   = [];\n\tvar enrichment       = [];\n\n\tfor (var i = 0; i < errors.length; i++) {\n\t\tif (errors[i].getElementsByTagName('string').item(0).firstChild !== null) {\n\t\t\tvar errorString      = errors[i].getElementsByTagName('string').item(0).firstChild.data;\n\t\t\tvar errorType        = errors[i].getElementsByTagName('type').item(0).firstChild.data;\n\t\t\tvar errorDescription = errors[i].getElementsByTagName('description').item(0).firstChild.data;\n\n\t\t\tvar errorContext;\n\n\t\t\tif (errors[i].getElementsByTagName('precontext').item(0).firstChild !== null) {\n\t\t\t\terrorContext = errors[i].getElementsByTagName('precontext').item(0).firstChild.data;\n\t\t\t} else {\n\t\t\t\terrorContext = '';\n\t\t\t}\n\n\t\t\t/* create a hashtable with information about the error in the editor object, we will use this later\n\t\t\t   to populate a popup menu with information and suggestions about the error */\n\n\t\t\tif (this.ignore_strings[errorString] === undefined) {\n\t\t\t\tvar suggestion = {};\n\t\t\t\tsuggestion['description'] = errorDescription;\n\t\t\t\tsuggestion['suggestions'] = [];\n\n\t\t\t\t/* used to find suggestions when a highlighted error is clicked on */\n\t\t\t\tsuggestion['matcher']     = new RegExp('^' + errorString.replace(/\\s+/, this._getSeparators()) + '$');\n\n\t\t\t\tsuggestion['context']     = errorContext;\n\t\t\t\tsuggestion['string']      = errorString;\n\t\t\t\tsuggestion['type']        = errorType;\n\n\t\t\t\tthis.suggestions.push(suggestion);\n\n\t\t\t\tif (errors[i].getElementsByTagName('suggestions').item(0) !== null) {\n\t\t\t\t\tvar suggestions = errors[i].getElementsByTagName('suggestions').item(0).getElementsByTagName('option');\n\t\t\t\t\tfor (var j = 0; j < suggestions.length; j++) {\n\t\t\t\t\t\tsuggestion['suggestions'].push(suggestions[j].firstChild.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* setup the more info url */\n\t\t\t\tif (errors[i].getElementsByTagName('url').item(0) !== null) {\n\t\t\t\t\tvar errorUrl = errors[i].getElementsByTagName('url').item(0).firstChild.data;\n\t\t\t\t\tsuggestion['moreinfo'] = errorUrl + '&theme=tinymce';\n\t\t\t\t}\n\n\t\t\t\tif (types[errorDescription] === undefined) {\n\t\t\t\t\tif (errorType === 'suggestion') {\n\t\t\t\t\t\tenrichment.push({ word: errorString, pre: errorContext });\n\t\t\t\t\t}\n\n\t\t\t\t\tif (errorType === 'grammar') {\n\t\t\t\t\t\tgrammarErrors.push({ word: errorString, pre: errorContext });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (errorType === 'spelling' || errorDescription === 'Homophone') {\n\t\t\t\t\tspellingErrors.push({ word: errorString, pre: errorContext });\n\t\t\t\t}\n\n\t\t\t\tif (errorDescription === 'Cliches') {\n\t\t\t\t\tsuggestion['description'] = 'Clichés'; /* done here for backwards compatability with current user settings */\n\t\t\t\t}\n\n\t\t\t\tif (errorDescription === 'Spelling') {\n\t\t\t\t\tsuggestion['description'] = this.getLang('menu_title_spelling', 'Spelling');\n\t\t\t\t}\n\n\t\t\t\tif (errorDescription === 'Repeated Word') {\n\t\t\t\t\tsuggestion['description'] = this.getLang('menu_title_repeated_word', 'Repeated Word');\n\t\t\t\t}\n\n\t\t\t\tif (errorDescription === 'Did you mean...') {\n\t\t\t\t\tsuggestion['description'] = this.getLang('menu_title_confused_word', 'Did you mean...');\n\t\t\t\t}\n\t\t\t} // end if ignore[errorString] == undefined\n\t\t} // end if\n\t} // end for loop\n\n\tvar errorStruct;\n        var ecount = spellingErrors.length + grammarErrors.length + enrichment.length;\n\n\tif (ecount > 0) {\n\t\terrorStruct = this.buildErrorStructure(spellingErrors, enrichment, grammarErrors);\n\t} else {\n\t\terrorStruct = undefined;\n\t}\n\n\t/* save some state in this object, for retrieving suggestions later */\n\treturn { errors: errorStruct, count: ecount, suggestions: this.suggestions };\n};\n\nAtDCore.prototype.findSuggestion = function(element) {\n        var text = element.innerHTML;\n        var context = ( this.getAttrib(element, 'pre') + '' ).replace(/[\\\\,!\\\\?\\\\.\"\\s]/g, '');\n        if (this.getAttrib(element, 'pre') === undefined) {\n           alert(element.innerHTML);\n        }\n\n\tvar errorDescription;\n\tvar len = this.suggestions.length;\n\n\tfor (var i = 0; i < len; i++) {\n\t\tif ((context === '' || context === this.suggestions[i]['context']) && this.suggestions[i]['matcher'].test(text)) {\n\t\t\terrorDescription = this.suggestions[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn errorDescription;\n};\n\n/*\n * TokenIterator class\n */\n\nfunction TokenIterator(tokens) {\n\tthis.tokens = tokens;\n\tthis.index  = 0;\n\tthis.count  = 0;\n\tthis.last   = 0;\n}\n\nTokenIterator.prototype.next = function() {\n\tvar current = this.tokens[this.index];\n\tthis.count = this.last;\n\tthis.last += current.length + 1;\n\tthis.index++;\n\n\t/* strip single quotes from token, AtD does this when presenting errors */\n\tif (current !== '') {\n\t\tif (current[0] === '\\'') {\n\t\t\tcurrent = current.substring(1, current.length);\n\t\t}\n\n\t\tif (current[current.length - 1] === '\\'') {\n\t\t\tcurrent = current.substring(0, current.length - 1);\n\t\t}\n\t}\n\n\treturn current;\n};\n\nTokenIterator.prototype.hasNext = function() {\n\treturn this.index < this.tokens.length;\n};\n\nTokenIterator.prototype.hasNextN = function(n) {\n\treturn (this.index + n) < this.tokens.length;\n};\n\nTokenIterator.prototype.skip = function(m, n) {\n\tthis.index += m;\n\tthis.last += n;\n\n\tif (this.index < this.tokens.length) {\n\t\tthis.count = this.last - this.tokens[this.index].length;\n\t}\n};\n\nTokenIterator.prototype.getCount = function() {\n\treturn this.count;\n};\n\nTokenIterator.prototype.peek = function(n) {\n\tvar peepers = [];\n\tvar end = this.index + n;\n\tfor (var x = this.index; x < end; x++) {\n\t\tpeepers.push(this.tokens[x]);\n\t}\n\treturn peepers;\n};\n\n/*\n *  code to manage highlighting of errors\n */\nAtDCore.prototype.markMyWords = function(container_nodes, errors) {\n\tvar seps = new RegExp(this._getSeparators()),\n\t\tnl = [],\n\t\tecount = 0, /* track number of highlighted errors */\n\t\tparent = this,\n\t\tbogus = this._isTinyMCE ? ' data-mce-bogus=\"1\"' : '',\n\t\temptySpan = '<span class=\"mceItemHidden\"' + bogus + '>&nbsp;</span>',\n\t\ttextOnlyMode;\n\n\t/**\n\t * Split a text node into an ordered list of siblings:\n\t * - text node to the left of the match\n\t * - the element replacing the match\n\t * - text node to the right of the match\n\t *\n\t * We have to leave the text to the left and right of the match alone\n\t * in order to prevent XSS\n\t *\n\t * @return array\n\t */\n\tfunction splitTextNode( textnode, regexp, replacement ) {\n\t\tvar text = textnode.nodeValue,\n\t\t\tindex = text.search( regexp ),\n\t\t\tmatch = text.match( regexp ),\n\t\t\tcaptured = [],\n\t\t\tcursor;\n\n\t\tif ( index < 0 || ! match.length ) {\n\t\t\treturn [ textnode ];\n\t\t}\n\n\t\tif ( index > 0 ) {\n\t\t\t// capture left text node\n\t\t\tcaptured.push( document.createTextNode( text.substr( 0, index ) ) );\n\t\t}\n\n\t\t// capture the replacement of the matched string\n\t\tcaptured.push( parent.create( match[0].replace( regexp, replacement ) ) );\n\n\t\tcursor = index + match[0].length;\n\n\t\tif ( cursor < text.length ) {\n\t\t\t// capture right text node\n\t\t\tcaptured.push( document.createTextNode( text.substr( cursor ) ) );\n\t\t}\n\n\t\treturn captured;\n\t}\n\n\tfunction _isInPre( node ) {\n\t\tif ( node ) {\n\t\t\twhile ( node.parentNode ) {\n\t\t\t\tif ( node.nodeName === 'PRE' ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tnode = node.parentNode;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/* Collect all text nodes */\n\t/* Our goal--ignore nodes that are already wrapped */\n\n\tthis._walk( container_nodes, function( n ) {\n\t\tif ( n.nodeType === 3 && ! parent.isMarkedNode( n ) && ! _isInPre( n ) ) {\n\t\t\tnl.push( n );\n\t\t}\n\t});\n\n\t/* walk through the relevant nodes */\n\n\tvar iterator;\n\n\tthis.map( nl, function( n ) {\n\t\tvar v;\n\n\t\tif ( n.nodeType === 3 ) {\n\t\t\tv = n.nodeValue; /* we don't want to mangle the HTML so use the actual encoded string */\n\t\t\tvar tokens = n.nodeValue.split( seps ); /* split on the unencoded string so we get access to quotes as \" */\n\t\t\tvar previous = '';\n\n\t\t\tvar doReplaces = [];\n\n\t\t\titerator = new TokenIterator(tokens);\n\n\t\t\twhile ( iterator.hasNext() ) {\n\t\t\t\tvar token = iterator.next();\n\t\t\t\tvar current  = errors['__' + token];\n\n\t\t\t\tvar defaults;\n\n\t\t\t\tif ( current !== undefined && current.pretoks !== undefined ) {\n\t\t\t\t\tdefaults = current.defaults;\n\t\t\t\t\tcurrent = current.pretoks['__' + previous];\n\n\t\t\t\t\tvar done = false;\n\t\t\t\t\tvar prev, curr;\n\n\t\t\t\t\tprev = v.substr(0, iterator.getCount());\n\t\t\t\t\tcurr = v.substr(prev.length, v.length);\n\n\t\t\t\t\tvar checkErrors = function( error ) {\n\t\t\t\t\t\tif ( error !== undefined && ! error.used && foundStrings[ '__' + error.string ] === undefined && error.regexp.test( curr ) ) {\n\t\t\t\t\t\t\tfoundStrings[ '__' + error.string ] = 1;\n\t\t\t\t\t\t\tdoReplaces.push([ error.regexp, '<span class=\"'+error.type+'\" pre=\"'+previous+'\"' + bogus + '>$&</span>' ]);\n\n\t\t\t\t\t\t\terror.used = true;\n\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}; // jshint ignore:line\n\n\t\t\t\t\tvar foundStrings = {};\n\n\t\t\t\t\tif (current !== undefined) {\n\t\t\t\t\t\tprevious = previous + ' ';\n\t\t\t\t\t\tparent.map(current, checkErrors);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!done) {\n\t\t\t\t\t\tprevious = '';\n\t\t\t\t\t\tparent.map(defaults, checkErrors);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevious = token;\n\t\t\t} // end while\n\n\t\t\t/* do the actual replacements on this span */\n\t\t\tif ( doReplaces.length > 0 ) {\n\t\t\t\tvar newNode = n;\n\n\t\t\t\tfor ( var x = 0; x < doReplaces.length; x++ ) {\n\t\t\t\t\tvar regexp = doReplaces[x][0], result = doReplaces[x][1];\n\n\t\t\t\t\t/* it's assumed that this function is only being called on text nodes (nodeType == 3), the iterating is necessary\n\t\t\t\t\t   because eventually the whole thing gets wrapped in an mceItemHidden span and from there it's necessary to\n\t\t\t\t\t   handle each node individually. */\n\t\t\t\t\tvar bringTheHurt = function( node ) {\n\t\t\t\t\t\tvar span, splitNodes;\n\n\t\t\t\t\t\tif ( node.nodeType === 3 ) {\n\t\t\t\t\t\t\tecount++;\n\n\t\t\t\t\t\t\t/* sometimes IE likes to ignore the space between two spans, solution is to insert a placeholder span with\n\t\t\t\t\t\t\t   a non-breaking space.  The markup removal code substitutes this span for a space later */\n\t\t\t\t\t\t\tif ( parent.isIE() && node.nodeValue.length > 0 && node.nodeValue.substr(0, 1) === ' ' ) {\n\t\t\t\t\t\t\t\treturn parent.create( emptySpan + node.nodeValue.substr( 1, node.nodeValue.length - 1 ).replace( regexp, result ), false );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif ( textOnlyMode ) {\n\t\t\t\t\t\t\t\t\treturn parent.create( node.nodeValue.replace( regexp, result ), false );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tspan = parent.create( '<span />' );\n\t\t\t\t\t\t\t\tif ( typeof textOnlyMode === 'undefined' ) {\n\t\t\t\t\t\t\t\t\t// cache this to avoid adding / removing nodes unnecessarily\n\t\t\t\t\t\t\t\t\ttextOnlyMode = typeof span.appendChild !== 'function';\n\t\t\t\t\t\t\t\t\tif ( textOnlyMode ) {\n\t\t\t\t\t\t\t\t\t\tparent.remove( span );\n\t\t\t\t\t\t\t\t\t\treturn parent.create( node.nodeValue.replace( regexp, result ), false );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// \"Visual\" mode\n\t\t\t\t\t\t\t\tsplitNodes = splitTextNode( node, regexp, result );\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < splitNodes.length; i++ ) {\n\t\t\t\t\t\t\t\t\tspan.appendChild( splitNodes[i] );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnode = span;\n\t\t\t\t\t\t\t\treturn node;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar contents = parent.contents(node);\n\n\t\t\t\t\t\t\tfor ( var y = 0; y < contents.length; y++ ) {\n\t\t\t\t\t\t\t\tif ( contents[y].nodeType === 3 && regexp.test( contents[y].nodeValue ) ) {\n\t\t\t\t\t\t\t\t\tvar nnode;\n\n\t\t\t\t\t\t\t\t\tif ( parent.isIE() && contents[y].nodeValue.length > 0 && contents[y].nodeValue.substr(0, 1) === ' ') {\n\t\t\t\t\t\t\t\t\t\tnnode = parent.create( emptySpan + contents[y].nodeValue.substr( 1, contents[y].nodeValue.length - 1 ).replace( regexp, result ), true );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnnode = parent.create( contents[y].nodeValue.replace( regexp, result ), true );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tparent.replaceWith( contents[y], nnode );\n\t\t\t\t\t\t\t\t\tparent.removeParent( nnode );\n\n\t\t\t\t\t\t\t\t\tecount++;\n\n\t\t\t\t\t\t\t\t\treturn node; /* we did a replacement so we can call it quits, errors only get used once */\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn node;\n\t\t\t\t\t\t}\n\t\t\t\t\t}; // jshint ignore:line\n\n\t\t\t\t\tnewNode = bringTheHurt(newNode);\n\t\t\t\t}\n\n\t\t\t\tparent.replaceWith(n, newNode);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn ecount;\n};\n\nAtDCore.prototype._walk = function(elements, f) {\n\tvar i;\n\tfor (i = 0; i < elements.length; i++) {\n\t\tf.call(f, elements[i]);\n\t\tthis._walk(this.contents(elements[i]), f);\n\t}\n};\n\nAtDCore.prototype.removeWords = function(node, w) {\n\tvar count = 0;\n\tvar parent = this;\n\n\tthis.map(this.findSpans(node).reverse(), function(n) {\n\t\tif (n && (parent.isMarkedNode(n) || parent.hasClass(n, 'mceItemHidden') || parent.isEmptySpan(n)) ) {\n\t\t\tif (n.innerHTML === '&nbsp;') {\n\t\t\t\tvar nnode = document.createTextNode(' '); /* hax0r */\n\t\t\t\tparent.replaceWith(n, nnode);\n\t\t\t} else if (!w || n.innerHTML === w) {\n\t\t\t\tparent.removeParent(n);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn count;\n};\n\nAtDCore.prototype.isEmptySpan = function(node) {\n\treturn (this.getAttrib(node, 'class') === '' && this.getAttrib(node, 'style') === '' && this.getAttrib(node, 'id') === '' && !this.hasClass(node, 'Apple-style-span') && this.getAttrib(node, 'mce_name') === '');\n};\n\nAtDCore.prototype.isMarkedNode = function(node) {\n\treturn (this.hasClass(node, 'hiddenGrammarError') || this.hasClass(node, 'hiddenSpellError') || this.hasClass(node, 'hiddenSuggestion'));\n};\n\n/*\n * Context Menu Helpers\n */\nAtDCore.prototype.applySuggestion = function(element, suggestion) {\n\tif (suggestion === '(omit)') {\n\t\tthis.remove(element);\n\t}\n\telse {\n\t\tvar node = this.create(suggestion);\n\t\tthis.replaceWith(element, node);\n\t\tthis.removeParent(node);\n\t}\n};\n\n/*\n * Check for an error\n */\nAtDCore.prototype.hasErrorMessage = function(xmlr) {\n\treturn (xmlr !== undefined && xmlr.getElementsByTagName('message').item(0) !== null);\n};\n\nAtDCore.prototype.getErrorMessage = function(xmlr) {\n\treturn xmlr.getElementsByTagName('message').item(0);\n};\n\n/* this should always be an error, alas... not practical */\nAtDCore.prototype.isIE = function() {\n\treturn navigator.appName === 'Microsoft Internet Explorer';\n};\n\n// TODO: this doesn't seem used anywhere in AtD, moved here from install_atd_l10n.js for eventual back-compat \n/* a quick poor man's sprintf */\nfunction atd_sprintf(format, values) {\n\tvar result = format;\n\tfor (var x = 0; x < values.length; x++) {\n\t\tresult = result.replace(new RegExp('%' + (x + 1) + '\\\\$', 'g'), values[x]);\n\t}\n\treturn result;\n}\n"]}