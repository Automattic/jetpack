<?php
/**
 * Jetpack Autoloader Generator.
 */

namespace Jetpack\Autoloader;

use Composer\Autoload\AutoloadGenerator as BaseGenerator;
use Composer\Autoload\ClassMapGenerator;
use Composer\Config;
use Composer\Installer\InstallationManager;
use Composer\IO\IOInterface;
use Composer\Package\PackageInterface;
use Composer\Repository\InstalledRepositoryInterface;
use Composer\Util\Filesystem;

/**
 * Class AutoloadGenerator.
 *
 * Generate the WordPress-specific class loader.
 *
 * @since   1.0.0
 *
 * @package WordPress\ComposerAutoload
 * @author  Alain Schlesser <alain.schlesser@gmail.com>
 */
class AutoloadGenerator extends BaseGenerator {

	private $devMode = false;
	/**
	 * @var IOInterface
	 */
	private $io;

	/**
	 * @var bool
	 */
	private $classMapAuthoritative = false;

	/**
	 * Instantiate a AutoloadGenerator object.
	 *
	 * @param IOInterface $io
	 */
	public function __construct( $io ) {
		$this->io = $io;
	}

	/**
	 * Whether or not generated autoloader considers the class map
	 * authoritative.
	 *
	 * @param bool $classMapAuthoritative
	 */
	public function setClassMapAuthoritative( $classMapAuthoritative ) {
		$this->classMapAuthoritative = (bool) $classMapAuthoritative;
	}

	/**
	 * Dump the autoloader.
	 *
	 * @param Config                       $config
	 * @param InstalledRepositoryInterface $localRepo
	 * @param PackageInterface             $mainPackage
	 * @param InstallationManager          $installationManager
	 * @param string                       $targetDir
	 * @param bool                         $scanPsr0Packages
	 * @param string                       $suffix
	 */
	public function dump(
		Config $config,
		InstalledRepositoryInterface $localRepo,
		PackageInterface $mainPackage,
		InstallationManager $installationManager,
		$targetDir,
		$scanPsr0Packages = false,
		$suffix = ''
	) {

		if ( $this->classMapAuthoritative ) {

			// Force scanPsr0Packages when classmap is authoritative
			$scanPsr0Packages = true;
		}

		$this->devMode = $scanPsr0Packages;

		$filesystem = new Filesystem();
		$filesystem->ensureDirectoryExists( $config->get( 'vendor-dir' ) );

		$basePath   = $filesystem->normalizePath( realpath( getcwd() ) );
		$vendorPath = $filesystem->normalizePath( realpath( $config->get( 'vendor-dir' ) ) );
		$targetDir  = $vendorPath . '/' . $targetDir;
		$filesystem->ensureDirectoryExists( $targetDir );

		$vendorPathCode = $filesystem->findShortestPathCode( realpath( $targetDir ), $vendorPath, true );

		$appBaseDirCode = $filesystem->findShortestPathCode( $vendorPath, $basePath, true );
		$appBaseDirCode = str_replace( '__DIR__', '$vendorDir', $appBaseDirCode );

		$packageMap = $this->buildPackageMap( $installationManager, $mainPackage, $localRepo->getCanonicalPackages() );
		$autoloads  = $this->parseAutoloads( $packageMap, $mainPackage );

		// add custom psr-0 autoloading if the root package has a target dir
		$targetDirLoader = null;

		$filesCode = '';
		// TODO: Test out file autoloading
		// $autoloads['files'] = new \RecursiveIteratorIterator(new \RecursiveArrayIterator($autoloads['files']));
		// foreach ($autoloads['files'] as $functionFile) {
		// don't include file if it is using PHP 5.3+ syntax
		// https://bitbucket.org/xrstf/composer-php52/issue/4
		// if ($this->isPHP53($functionFile)) {
		// $filesCode .= '//       require ' . $this->getPathCode($filesystem, $basePath, $vendorPath,
		// $functionFile) . "; // disabled because of PHP 5.3 syntax\n";
		// } else {
		// $filesCode .= '     require ' . $this->getPathCode($filesystem, $basePath, $vendorPath,
		// $functionFile) . ";\n";
		// }
		// }

		$classmapFile = <<<EOF
<?php

// autoload_classmap_package.php @generated by automattic/autoload

\$vendorDir = $vendorPathCode;
\$baseDir = $appBaseDirCode;

return array(

EOF;

		$blacklist = null;
		if ( ! empty( $autoloads['exclude-from-classmap'] ) ) {
			$blacklist = '{(' . implode( '|', $autoloads['exclude-from-classmap'] ) . ')}';
		}

		// flatten array
		$classMap = array();
		if ( $scanPsr0Packages ) {
			$namespacesToScan = array();

			// Scan the PSR-0/4 directories for class files, and add them to the class map
			foreach ( array( 'psr-0', 'psr-4' ) as $psrType ) {
				foreach ( $autoloads[ $psrType ] as $namespace => $info ) {
					$version = array_reduce(
						array_map(
							function( $item ) {
									return $item['version']; },
							$info
						),
						function( $carry, $version ) {
							return version_compare( $version, $carry, '>' ) ? $version : $carry;
						},
						0
					);

					$namespacesToScan[ $namespace ][] = array(
						'paths'   => array_map(
							function( $item ) {
									return $item['path']; },
							$info
						),
						'type'    => $psrType,
						'name'    => array_map(
							function( $item ) {
									return $item['name']; },
							$info
						),
						'version' => $version,
					);
				}
			}

			krsort( $namespacesToScan );

			foreach ( $namespacesToScan as $namespace => $groups ) {
				foreach ( $groups as $group ) {
					$psrType = $group['type'];
					foreach ( $group['paths'] as $dir ) {
						$dir = $filesystem->normalizePath( $filesystem->isAbsolutePath( $dir ) ? $dir : $basePath . '/' . $dir );
						if ( ! is_dir( $dir ) ) {
							continue;
						}

						$namespaceFilter = $namespace === '' ? null : $namespace;
						$classMap        = $this->addClassMapCode(
							$filesystem,
							$basePath,
							$vendorPath,
							$dir,
							$blacklist,
							$namespaceFilter,
							$group['version'],
							$classMap
						);
					}
				}
			}
		}
		// todo: test this out.
		// foreach ($autoloads['classmap'] as $dir) {
		// $classMap = $this->addClassMapCode($filesystem, $basePath, $vendorPath, $dir, $blacklist, null, '1', $classMap);
		// }

		ksort( $classMap );
		foreach ( $classMap as $class => $code ) {
			$classmapFile .= '    ' . var_export( $class, true ) . ' => ' . $code;
		}
		$classmapFile .= ");\n";

		file_put_contents( $targetDir . '/autoload_classmap_package.php', $classmapFile );

		$sourceLoader = fopen( __DIR__ . '/autoload.php', 'r' );
		$targetLoader = fopen( $vendorPath . '/autoload_packages.php', 'w+' );
		fwrite( $targetLoader, stream_get_contents( $sourceLoader ) );

	}

	/**
	 * This function differes from the composer parseAutoloadsType in that beside returning the path.
	 * It also return the name and the version of a package.
	 *
	 * @param array            $packageMap
	 * @param $type
	 * @param PackageInterface $mainPackage
	 *
	 * @return array
	 */
	protected function parseAutoloadsType( array $packageMap, $type, PackageInterface $mainPackage ) {
		$autoloads = array();
		foreach ( $packageMap as $item ) {
			list($package, $installPath) = $item;
			$autoload                    = $package->getAutoload();
			if ( $this->devMode && $package === $mainPackage ) {
				$autoload = array_merge_recursive( $autoload, $package->getDevAutoload() );
			}
			// skip misconfigured packages
			if ( ! isset( $autoload[ $type ] ) || ! is_array( $autoload[ $type ] ) ) {
				continue;
			}
			if ( null !== $package->getTargetDir() && $package !== $mainPackage ) {
				$installPath = substr( $installPath, 0, -strlen( '/' . $package->getTargetDir() ) );
			}
			foreach ( $autoload[ $type ] as $namespace => $paths ) {
				foreach ( (array) $paths as $path ) {
					if ( ( $type === 'files' || $type === 'classmap' || $type === 'exclude-from-classmap' ) && $package->getTargetDir() && ! is_readable( $installPath . '/' . $path ) ) {
						// remove target-dir from file paths of the root package
						if ( $package === $mainPackage ) {
							$targetDir = str_replace( '\\<dirsep\\>', '[\\\\/]', preg_quote( str_replace( array( '/', '\\' ), '<dirsep>', $package->getTargetDir() ) ) );
							$path      = ltrim( preg_replace( '{^' . $targetDir . '}', '', ltrim( $path, '\\/' ) ), '\\/' );
						} else {
							// add target-dir from file paths that don't have it
							$path = $package->getTargetDir() . '/' . $path;
						}
					}
					if ( $type === 'exclude-from-classmap' ) {
						// first escape user input
						$path = preg_replace( '{/+}', '/', preg_quote( trim( strtr( $path, '\\', '/' ), '/' ) ) );
						// add support for wildcards * and **
						$path = str_replace( '\\*\\*', '.+?', $path );
						$path = str_replace( '\\*', '[^/]+?', $path );
						// add support for up-level relative paths
						$updir = null;
						$path  = preg_replace_callback(
							'{^((?:(?:\\\\\\.){1,2}+/)+)}',
							function ( $matches ) use ( &$updir ) {
								if ( isset( $matches[1] ) ) {
									// undo preg_quote for the matched string
									$updir = str_replace( '\\.', '.', $matches[1] );
								}
								return '';
							},
							$path
						);
						if ( empty( $installPath ) ) {
							$installPath = strtr( getcwd(), '\\', '/' );
						}
						$resolvedPath = realpath( $installPath . '/' . $updir );
						$autoloads[]  = preg_quote( strtr( $resolvedPath, '\\', '/' ) ) . '/' . $path;
						continue;
					}
					$relativePath = empty( $installPath ) ? ( empty( $path ) ? '.' : $path ) : $installPath . '/' . $path;
					if ( $type === 'files' ) {
						$autoloads[ $this->getFileIdentifier( $package, $path ) ] = $relativePath;
						continue;
					} elseif ( $type === 'classmap' ) {
						$autoloads[] = $relativePath;
						continue;
					}
					$autoloads[ $namespace ][] = array(
						'path'    => $relativePath,
						'version' => $package->getVersion(),
						'name'    => $package->getName(),
					);
				}
			}
		}
		return $autoloads;
	}

	/**
	 * Add a single class map resolution.
	 *
	 * @param Filesystem $filesystem
	 * @param string     $basePath
	 * @param string     $vendorPath
	 * @param string     $dir
	 * @param null       $blacklist
	 * @param null       $namespaceFilter
	 * @param string     $version
	 * @param array      $classMap
	 *
	 * @return array
	 */
	private function addClassMapCode(
		$filesystem,
		$basePath,
		$vendorPath,
		$dir,
		$blacklist = null,
		$namespaceFilter = null,
		$version,

		array $classMap = array()
	) {

		foreach ( $this->generateClassMap( $dir, $blacklist, $namespaceFilter ) as $class => $path ) {
			$pathCode = "array( 'path' => " . $this->getPathCode( $filesystem, $basePath, $vendorPath, $path ) . ", 'version'=>'" . $version . "' ),\n";

			if ( ! isset( $classMap[ $class ] ) ) {
				$classMap[ $class ] = $pathCode;
			} elseif ( $this->io && $classMap[ $class ] !== $pathCode && ! preg_match(
				'{/(test|fixture|example|stub)s?/}i',
				strtr( $classMap[ $class ] . ' ' . $path, '\\', '/' )
			)
			) {
				$this->io->writeError(
					'<warning>Warning: Ambiguous class resolution, "' . $class . '"' .
					' was found in both "' . str_replace(
						array( '$vendorDir . \'', "',\n" ),
						array( $vendorPath, '' ),
						$classMap[ $class ]
					) . '" and "' . $path . '", the first will be used.</warning>'
				);
			}
		}

		return $classMap;
	}

	/**
	 * Trigger the class map generation.
	 *
	 * @param string $dir
	 * @param null   $blacklist
	 * @param null   $namespaceFilter
	 * @param bool   $showAmbiguousWarning
	 *
	 * @return array
	 */
	private function generateClassMap( $dir, $blacklist = null, $namespaceFilter = null, $showAmbiguousWarning = true ) {
		return ClassMapGenerator::createMap(
			$dir,
			$blacklist,
			$showAmbiguousWarning ? $this->io : null,
			$namespaceFilter
		);
	}

}
